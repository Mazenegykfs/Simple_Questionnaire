<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questionnaire Results Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include SheetJS and Chart.js libraries -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <!-- Include Chart.js Datalabels Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e5e7eb;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        /* Fix for table header cells */
        #resultsTable th {
            white-space: nowrap;
        }
        .ranking-option {
            display: flex;
            align-items: center;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .ranking-option-text {
            flex-grow: 1;
            font-weight: 500;
            color: #374151;
        }
        .ranking-option-buttons {
            display: flex;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        .ranking-option-buttons button {
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .ranking-option-buttons .move-button {
            background-color: #a78bfa; /* Purple 400 */
            color: white;
        }
        .ranking-option-buttons .move-button:hover {
            background-color: #8b5cf6; /* Purple 500 */
        }
        .ranking-option-buttons .remove-button {
            background-color: #ef4444; /* Red 500 */
            color: white;
        }
        .ranking-option-buttons .remove-button:hover {
            background-color: #dc2626; /* Red 600 */
        }
    </style>
</head>
<body class="p-6 md:p-12">
    <!-- Language switch button container -->
    <div style="position: absolute; top: 1.5rem; left: 1.5rem; z-index: 100;" class="flex flex-col space-y-2">
        <div id="langToggle" class="flex rounded-lg shadow-md overflow-hidden cursor-pointer transition-colors duration-300">
            <span id="lang-en" class="px-6 py-3 font-semibold transition-colors duration-300">English</span>
            <span id="lang-ar" class="px-6 py-3 font-semibold transition-colors duration-300">العربية</span>
        </div>
        <!-- New template buttons -->
        <div class="flex space-x-2">
            <button id="showVerticalTemplateBtn" class="px-4 py-2 bg-gray-300 text-gray-800 text-sm font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-300">
                Vertical Template
            </button>
            <button id="showHorizontalTemplateBtn" class="px-4 py-2 bg-gray-300 text-gray-800 text-sm font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-300">
                Horizontal Template
            </button>
        </div>
    </div>

    <!-- Logo at the top right -->
    <div style="position: absolute; top: 1.5rem; right: 1.5rem; z-index: 100;">
        <img src="https://placehold.co/80x80/ffffff/000000?text=Logo" alt="Logo" class="h-20 w-20 shadow-md rounded-full">
    </div>
    <div class="max-w-7xl mx-auto bg-white p-8 rounded-2xl shadow-xl">
        <h1 id="mainTitle" class="text-3xl font-bold text-center mb-1 text-gray-800">Questionnaire Results Analysis</h1>
        <p class="text-center text-gray-600 mb-6 text-xl font-bold" id="developerCredit">Developed by Dr. Mazen Badawy – Doctorate of English Teaching & Testing</p>
        
        <p id="subtitle" class="text-center text-gray-600 mb-8">Upload your Excel (XLSX) file with the questionnaire results to view the analysis.</p>
        <!-- Data Orientation switch button -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <p id="dataOrientationLabel" class="text-gray-700 font-semibold">Data Orientation:</p>
            <div id="dataOrientationToggle" class="flex rounded-lg shadow-md overflow-hidden cursor-pointer transition-colors duration-300">
                <span id="orientation-vertical" class="px-6 py-3 font-semibold transition-colors duration-300">Vertical</span>
                <span id="orientation-horizontal" class="px-6 py-3 font-semibold transition-colors duration-300">Horizontal</span>
            </div>
        </div>
        
        <!-- File input and loading indicator -->
        <div id="fileUploadSection" class="flex flex-col items-center space-y-4 mb-8">
            <label for="xlsxFile" class="block w-full text-center">
                <span id="fileButtonText" class="inline-block px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition-colors duration-300 cursor-pointer">
                    Choose XLSX File
                </span>
                <input type="file" id="xlsxFile" class="hidden" accept=".xlsx, .xls">
            </label>
            <div id="loadingMessage" class="hidden text-gray-500">
                Processing data, please wait...
            </div>
            <!-- Message Box for errors -->
            <div id="messageBox" class="hidden bg-red-100 border-r-4 border-red-500 text-red-700 p-4 w-full rounded-md" role="alert">
                <div class="flex items-center">
                    <svg class="h-6 w-6 text-red-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold" id="messageTitle">Error!</p>
                        <p id="messageText" class="text-sm"></p>
                    </div>
                </div>
            </div>
        </div>
        <!-- New section for scale order definition (Ranking Widget) -->
        <div id="scaleOrderSection" class="hidden w-full max-w-2xl mx-auto mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
            <h2 id="scaleOrderTitle" class="text-xl font-bold text-gray-700 mb-4">Define Scale Order (Ranking Widget)</h2>
            <p id="scaleOrderSubtitle" class="text-gray-600 mb-4">Arrange the automatically recognized response categories in the desired order (highest value at the top).</p>
            <div class="flex flex-col items-center space-y-2 mb-4">
                <label class="block w-full text-center text-sm font-medium text-gray-700" for="positivesThresholdInput">
                    Positives Threshold:
                </label>
                <input type="number" id="positivesThresholdInput" value="85" min="0" max="100" class="w-24 px-2 py-1 text-center border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
            </div>
            <div id="scaleOrderOptionsContainer" class="space-y-2">
                <!-- Ranking options will be dynamically inserted here -->
            </div>
            <!-- Message Box for scale order errors -->
            <div id="scaleOrderMessageBox" class="hidden bg-red-100 border-r-4 border-red-500 text-red-700 p-4 w-full rounded-md mt-4" role="alert">
                <div class="flex items-center">
                    <svg class="h-6 w-6 text-red-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold" id="scaleOrderMessageTitle">Error!</p>
                        <p id="scaleOrderMessageText" class="text-sm"></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action buttons container -->
        <div id="actionButtons" class="hidden flex flex-row justify-center space-x-4 space-x-reverse:rtl mb-8">
            <button id="analyzeButton" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300">
                Analyze Data
            </button>
            <button id="exportButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300">
                Export to XLSX
            </button>
            <button id="copyTableButton" class="px-6 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700 transition-colors duration-300">
                Copy All Tables
            </button>
        </div>

        <!-- New elements for file name and participant count -->
        <p id="fileNameDisplay" class="text-center text-gray-800 mb-2 font-bold hidden"></p>
        <p id="participantCountDisplay" class="text-center text-gray-700 mb-8 hidden"></p>

        <!-- The results table container -->
        <div id="resultsContainer" class="hidden overflow-x-auto">
            <!-- Tables for each domain will be injected here -->
        </div>
        <!-- Charts container -->
        <div id="chartContainer" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-8">
            <!-- Charts will be injected here -->
            <div class="p-6 bg-gray-50 rounded-xl shadow-inner flex flex-col justify-center items-center">
                <h3 class="text-lg font-semibold mb-4 text-gray-700" id="fullChartTitle"></h3>
                <div class="h-64 w-full">
                    <canvas id="fullResultsChart"></canvas>
                </div>
            </div>
        </div>
        <!-- Sections for Positive and Negative Items -->
        <div id="positiveNegativeItemsContainer" class="hidden">
            <!-- These divs will be dynamically injected by renderPositiveItemsLists -->
        </div>
    </div>
    <!-- Template Guide Container (initially hidden) -->
    <div id="templateGuideContainer" class="hidden fixed top-28 left-12 z-10 bg-white p-6 rounded-lg shadow-xl border border-gray-200 w-96 max-w-full">
        <div class="flex justify-between items-center mb-4">
            <h3 id="templateGuideTitle" class="text-lg font-bold text-gray-800"></h3>
            <button id="closeTemplateGuideBtn" class="text-gray-500 hover:text-gray-700 font-bold text-xl">&times;</button>
        </div>
        <div id="verticalTemplateContent" class="hidden">
            <p id="verticalTemplateDescription" class="text-gray-600 mb-2 text-sm"></p>
            <table class="w-full text-sm text-left text-gray-700 border border-gray-300 rounded-md overflow-hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="px-3 py-2 border-r border-b" id="vtHeaderItem"></th>
                        <th class="px-3 py-2 border-r border-b" id="vtHeaderResp1"></th>
                        <th class="px-3 py-2 border-b" id="vtHeaderResp2"></th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="px-3 py-2 border-r border-b">Question 1</td>
                        <td class="px-3 py-2 border-r border-b">Agree</td>
                        <td class="px-3 py-2 border-b">Disagree</td>
                    </tr>
                    <tr>
                        <td class="px-3 py-2 border-r">Question 2</td>
                        <td class="px-3 py-2 border-r">Neutral</td>
                        <td class="px-3 py-2">Agree</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="horizontalTemplateContent" class="hidden">
            <p id="horizontalTemplateDescription" class="text-gray-600 mb-2 text-sm"></p>
            <table class="w-full text-sm text-left text-gray-700 border border-gray-300 rounded-md overflow-hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="px-3 py-2 border-r border-b" id="htHeaderEmpty"></th>
                        <th class="px-3 py-2 border-r border-b" id="htHeaderItem1"></th>
                        <th class="px-3 py-2 border-b" id="htHeaderItem2"></th>
                        </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="px-3 py-2 border-r border-b" id="htRow1Resp">Respondent 1</td>
                        <td class="px-3 py-2 border-r border-b">Agree</td>
                        <td class="px-3 py-2 border-b">Neutral</td>
                    </tr>
                    <tr>
                        <td class="px-3 py-2 border-r">Respondent 2</td>
                        <td class="px-3 py-2 border-r">Disagree</td>
                        <td class="px-3 py-2">Agree</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', (event) => {
        // Register the datalabels plugin globally
        Chart.register(ChartDataLabels);

        // Get references to DOM elements
        const xlsxFile = document.getElementById('xlsxFile');
        const loadingMessage = document.getElementById('loadingMessage');
        const resultsContainer = document.getElementById('resultsContainer');
        const chartContainer = document.getElementById('chartContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const exportButton = document.getElementById('exportButton');
        const copyTableButton = document.getElementById('copyTableButton');
        const langToggle = document.getElementById('langToggle');
        const langEnSpan = document.getElementById('lang-en');
        const langArSpan = document.getElementById('lang-ar');
        const analyzeButton = document.getElementById('analyzeButton');
        const actionButtons = document.getElementById('actionButtons');
        const positiveNegativeItemsContainer = document.getElementById('positiveNegativeItemsContainer');
        const fileNameDisplay = document.getElementById('fileNameDisplay'); // New element
        const participantCountDisplay = document.getElementById('participantCountDisplay'); // New element

        // Data orientation elements
        const dataOrientationToggle = document.getElementById('dataOrientationToggle');
        const orientationVerticalSpan = document.getElementById('orientation-vertical');
        const orientationHorizontalSpan = document.getElementById('orientation-horizontal');
        const dataOrientationLabel = document.getElementById('dataOrientationLabel');

        // Scale order (Ranking Widget) elements
        const scaleOrderSection = document.getElementById('scaleOrderSection');
        const scaleOrderOptionsContainer = document.getElementById('scaleOrderOptionsContainer');
        const scaleOrderMessageBox = document.getElementById('scaleOrderMessageBox');
        const scaleOrderMessageText = document.getElementById('scaleOrderMessageText');
        const scaleOrderMessageTitle = document.getElementById('scaleOrderMessageTitle');
        const positivesThresholdInput = document.getElementById('positivesThresholdInput');

        // Template buttons and guide elements
        const showVerticalTemplateBtn = document.getElementById('showVerticalTemplateBtn');
        const showHorizontalTemplateBtn = document.getElementById('showHorizontalTemplateBtn');
        const templateGuideContainer = document.getElementById('templateGuideContainer');
        const closeTemplateGuideBtn = document.getElementById('closeTemplateGuideBtn');
        const templateGuideTitle = document.getElementById('templateGuideTitle');
        const verticalTemplateContent = document.getElementById('verticalTemplateContent');
        const horizontalTemplateContent = document.getElementById('horizontalTemplateContent');

        // Define language data for easy switching
        const languageData = {
            en: {
                title: 'Questionnaire Results Analysis',
                subtitle: 'Upload your Excel (XLSX) file with the questionnaire results to view the analysis.',
                fileButton: 'Choose XLSX File',
                loading: 'Processing data, please wait...',
                error: 'Error!',
                fileError: 'Please select an Excel (XLSX) file.',
                parseError: 'An error occurred while processing the file. Please ensure it is a valid Excel (XLSX) file.',
                emptyFile: 'The file is empty or contains only one row.',
                langButton: 'العربية',
                exportButton: 'Export to XLSX',
                copyTableButton: 'Copy All Tables',
                tableCopied: 'All tables copied to clipboard!',
                analyzeButton: 'Analyze Data',
                domainLabel: 'Domain',
                domainAverages: 'Domain Averages',
                tableHeaders: {
                    no: 'No.',
                    item: 'Item',
                    positives: 'Positives', // New header
                    totalColumn: 'Total', // For the 100% column
                    totalRowLabel: 'Totals', // For the footer row
                    totalPercentageLabel: 'Overall Percentage Sum' // For the 100% check text
                },
                chartTitle: 'Percentage Distribution of Responses',
                domainChartTitle: '{number}', // Changed chart title
                domainAveragesChartTitle: 'Overall Averages', // Changed chart title
                dataOrientationLabel: 'Data Orientation:',
                orientationVertical: 'Vertical',
                orientationHorizontal: 'Horizontal',
                scaleOrderTitle: 'Define Scale Order (Ranking Widget)',
                scaleOrderSubtitle: 'Arrange the automatically recognized response categories in the desired order (highest value at the top).',
                scaleOrderEmpty: 'Please add at least one response category.',
                scaleOrderDuplicate: 'Duplicate response category found. Please ensure all categories are unique.',
                positiveLabel: 'Positive', // New translation
                templateButtons: {
                    vertical: 'Vertical Template',
                    horizontal: 'Horizontal Template'
                },
                templateGuide: {
                    title: 'XLSX File Template Guide',
                    verticalDesc: 'For Vertical data, items are in Column A, and responses start from Column B:',
                    horizontalDesc: 'For Horizontal data, items are in Row 1, and responses start from Row 2:',
                    vtHeaderItem: 'Item Name',
                    vtHeaderResp: 'Response',
                    htHeaderEmpty: 'ID/Empty',
                    htHeaderItem: 'Item',
                    htRowResp: 'Respondent'
                },
                positiveItemsTitle: 'Positive Items', // Renamed title
                negativeItemsTitle: 'Negative Items' // Renamed title
            },
            ar: {
                title: 'تحليل نتائج الاستبيان',
                subtitle: 'قم بتحميل ملف Excel (XLSX) الخاص بنتائج الاستبيان لعرض التحليل.',
                fileButton: 'اختر ملف XLSX',
                loading: 'جاري تحميل وتحليل البيانات، يرجى الانتظار...',
                error: 'خطأ!',
                fileError: 'يرجى تحديد ملف Excel (XLSX).',
                parseError: 'حدث خطأ أثناء معالجة الملف. يرجى التأكد من أنه ملف Excel (XLSX) صحيح.',
                emptyFile: 'الملف فارغ أو يحتوي على صف واحد فقط.',
                langButton: 'English',
                exportButton: 'تصدير إلى XLSX',
                copyTableButton: 'نسخ جميع الجداول',
                tableCopied: 'تم نسخ جميع الجداول إلى الحافظة!',
                analyzeButton: 'تحليل البيانات',
                domainLabel: 'المجال',
                domainAverages: 'متوسطات المجال',
                tableHeaders: {
                    no: 'الرقم',
                    item: 'العناصر',
                    positives: 'الإيجابيات', // New header
                    totalColumn: 'الإجمالي', // For the 100% column
                    totalRowLabel: 'المجاميع', // For the footer row
                    totalPercentageLabel: 'المجموع الكلي للنسب المئوية' // For the 100% check text
                },
                chartTitle: 'توزيع الاستجابات بالنسبة المئوية',
                domainChartTitle: '{number}', // Changed chart title
                domainAveragesChartTitle: 'المتوسطات الكلية', // Changed chart title
                dataOrientationLabel: 'اتجاه البيانات:',
                orientationVertical: 'عمودي',
                orientationHorizontal: 'أفقي',
                scaleOrderTitle: 'تحديد ترتيب المقياس (أداة الترتيب)',
                scaleOrderSubtitle: 'أضف فئات الاستجابة وقم بترتيبها بالترتيب المطلوب (أعلى قيمة في الأعلى).',
                scaleOrderEmpty: 'الرجاء إضافة فئة استجابة واحدة على الأقل.',
                scaleOrderDuplicate: 'تم العثور على فئة استجابة مكررة. يرجى التأكد من أن جميع الفئات فريدة.',
                positiveLabel: 'إيجابي', // New translation
                templateButtons: {
                    vertical: 'قالب عمودي',
                    horizontal: 'قالب أفقي'
                },
                templateGuide: {
                    title: 'دليل قالب ملف XLSX',
                    verticalDesc: 'للبيانات العمودية، تكون البنود في العمود A، وتبدأ الاستجابات من العمود B:',
                    horizontalDesc: 'للبيانات الأفقية، تكون البنود في الصف 1، وتبدأ الاستجابات من الصف 2:',
                    vtHeaderItem: 'اسم البند',
                    vtHeaderResp: 'الاستجابة',
                    htHeaderEmpty: 'المعرف/فارغ',
                    htHeaderItem: 'البند',
                    htRowResp: 'المستجيب'
                },
                positiveItemsTitle: 'البنود الإيجابية', // Renamed title
                negativeItemsTitle: 'البنود السلبية' // Renamed title
            }
        };

        // Define a default mapping for Likert scale responses to numerical values.
        const defaultResponseValueMap = {
            'أوافق تماما': 5,
            'أوافق': 4,
            'أوافق إلي حد ما': 3,
            'لا أوافق': 2,
            'لا أوافق مطلقا': 1,
            'Strongly Agree': 5,
            'Agree': 4,
            'Neutral': 3,
            'Disagree': 2,
            'Strongly Disagree': 1
        };
        let currentResponseValueMap = { ...defaultResponseValueMap }; // Active map, can be overridden
        let currentScaleOptions = Object.keys(defaultResponseValueMap).sort((a, b) => defaultResponseValueMap[b] - defaultResponseValueMap[a]);
        let positiveScaleOptions = new Set(); // New Set to store positive scale options

        const responseColors = [
            'rgb(54, 162, 235)', // Light blue for positive
            'rgb(75, 192, 192)', // Green for agree
            'rgb(255, 205, 86)', // Yellow for neutral
            'rgb(255, 99, 132)', // Red for disagree
            'rgb(201, 203, 207)'  // Grey for strongly disagree
        ];

        let currentLang = 'en';
        let dataOrientation = 'vertical'; // Default data orientation
        let allCharts = {}; // Store chart instances to destroy them later

        /**
         * Transposes a 2D array.
         * @param {Array<Array<any>>} array The 2D array to transpose.
         * @returns {Array<Array<any>>} The transposed 2D array.
         */
        function transposeArray(array) {
            if (!array || array.length === 0 || array[0].length === 0) {
                return [];
            }
            const numRows = array.length;
            const numCols = array[0].length;
            const transposed = [];

            for (let j = 0; j < numCols; j++) {
                transposed[j] = [];
                for (let i = 0; i < numRows; i++) {
                    transposed[j][i] = array[i][j];
                }
            }
            return transposed;
        }

        // Event listener for file selection
        xlsxFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                showMessage(languageData[currentLang].fileError, 'error');
                return;
            }

            loadingMessage.classList.remove('hidden');
            // Hide all subsequent sections when a new file is chosen
            resultsContainer.classList.add('hidden');
            chartContainer.classList.add('hidden');
            actionButtons.classList.add('hidden');
            messageBox.classList.add('hidden');
            scaleOrderMessageBox.classList.add('hidden');
            scaleOrderSection.classList.add('hidden');
            positiveNegativeItemsContainer.classList.add('hidden');

            fileNameDisplay.textContent = file.name;
            fileNameDisplay.classList.remove('hidden');
            participantCountDisplay.classList.add('hidden'); // Hide until analyzed

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const parsedData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    if (parsedData.length < 2) {
                        showMessage(languageData[currentLang].emptyFile, 'error');
                        return;
                    }
                                        
                    sessionStorage.setItem('parsedData', JSON.stringify(parsedData));

                    const identifiedResponses = new Set();
                    let dataToScanForResponses = [];

                    if (dataOrientation === 'vertical') {
                        dataToScanForResponses = parsedData.slice(1).flatMap(row => row.slice(1));
                    } else {
                        dataToScanForResponses = parsedData.slice(1).flatMap(row => row.slice(1));
                    }

                    dataToScanForResponses.forEach(response => {
                        if (typeof response === 'string' && response.trim() !== '' && isNaN(Number(response))) {
                            identifiedResponses.add(String(response).trim());
                        }
                    });

                    const sortedIdentifiedResponses = Array.from(identifiedResponses).sort((a, b) => {
                        const valA = currentResponseValueMap[a] !== undefined ? currentResponseValueMap[a] : -Infinity;
                        const valB = defaultResponseValueMap[b] !== undefined ? defaultResponseValueMap[b] : -Infinity;

                        if (valA !== -Infinity && valB !== -Infinity) {
                            return valB - valA;
                        } else if (valA !== -Infinity) {
                            return -1;
                        } else if (valB !== -Infinity) {
                            return 1;
                        }
                        return a.localeCompare(b);
                    });

                    currentScaleOptions = sortedIdentifiedResponses;
                    // Reset positiveScaleOptions if new data is loaded
                    positiveScaleOptions.clear();
                    // Pre-select known positive options if they exist in the identified responses
                    ['Strongly Agree', 'Agree', 'أوافق تماما', 'أوافق'].forEach(positiveOption => {
                        if (identifiedResponses.has(positiveOption)) {
                            positiveScaleOptions.add(positiveOption);
                        }
                    });

                    renderScaleOptions(); // This will render and show the scale order section
                    actionButtons.classList.remove('hidden'); // Show action buttons

                    scaleOrderSection.classList.remove('hidden'); // Show ranking widget after file upload
                } catch (error) {
                    console.error("Error parsing or displaying data:", error);
                    showMessage(languageData[currentLang].parseError, 'error');
                } finally {
                    if (loadingMessage) loadingMessage.classList.add('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // Event listener for "Analyze Data" button
        analyzeButton.addEventListener('click', () => {
            const storedParsedData = JSON.parse(sessionStorage.getItem('parsedData'));
            if (!storedParsedData) {
                showMessage(languageData[currentLang].fileError, 'error');
                return;
            }

            if (currentScaleOptions.length === 0) {
                showScaleOrderMessage(languageData[currentLang].scaleOrderEmpty, 'error');
                return;
            }

            // Calculate number of participants based on orientation
            let numParticipants;
            if (dataOrientation === 'vertical') {
                // If vertical, first row after header contains responses, and each subsequent column is a participant
                // So, number of participants is the length of the second row (index 1) minus 1 (for the item name column)
                numParticipants = storedParsedData.length > 1 && storedParsedData[1].length > 1 ? storedParsedData[1].length - 1 : 0;
            } else {
                // If horizontal, each row after the header row is a participant
                numParticipants = storedParsedData.length > 1 ? storedParsedData.length - 1 : 0;
            }
            participantCountDisplay.textContent = `${numParticipants} Participants`;
            participantCountDisplay.classList.remove('hidden');

            // Call the new domain-detection analysis function
            displayDomainResults(storedParsedData);

            resultsContainer.classList.remove('hidden');
            chartContainer.classList.remove('hidden');
            positiveNegativeItemsContainer.classList.remove('hidden');
        });

        // Function to display messages (error/info)
        function showMessage(msg, type = 'info') {
            messageBox.classList.remove('hidden');
            messageText.textContent = msg;
            if (type === 'error') {
                messageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                messageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                messageBox.querySelector('svg path').setAttribute('fill-rule', 'evenodd');
                messageBox.querySelector('svg path').setAttribute('d', 'M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z');
                messageBox.querySelector('svg path').setAttribute('clip-rule', 'evenodd');
                document.getElementById('messageTitle').textContent = languageData[currentLang].error;
            } else {
                messageBox.classList.remove('bg-red-100', 'border-red-500', 'text-red-700');
                messageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                messageBox.querySelector('svg path').removeAttribute('fill-rule');
                messageBox.querySelector('svg path').removeAttribute('d');
                messageBox.querySelector('svg path').setAttribute('d', 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');
                document.getElementById('messageTitle').textContent = 'Info!'; // Or other info title
            }
        }

        // Function to show messages specifically for scale order
        function showScaleOrderMessage(msg, type = 'info') {
            scaleOrderMessageBox.classList.remove('hidden');
            scaleOrderMessageText.textContent = msg;
            if (type === 'error') {
                scaleOrderMessageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                scaleOrderMessageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('fill-rule', 'evenodd');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('d', 'M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('clip-rule', 'evenodd');
                scaleOrderMessageTitle.textContent = languageData[currentLang].error;
            } else {
                scaleOrderMessageBox.classList.remove('bg-red-100', 'border-red-500', 'text-red-700');
                scaleOrderMessageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                scaleOrderMessageBox.querySelector('svg path').removeAttribute('fill-rule');
                scaleOrderMessageBox.querySelector('svg path').removeAttribute('d');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('d', 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');
                scaleOrderMessageTitle.textContent = 'Info!';
            }
        }

        // Function to process and display results by domain
        function displayDomainResults(data) {
            resultsContainer.innerHTML = '';
            chartContainer.innerHTML = ''; // Clear charts
            positiveNegativeItemsContainer.innerHTML = ''; // Clear positive/negative items
            destroyAllCharts(); // Destroy existing chart instances

            let items;
            let responses;
            if (dataOrientation === 'vertical') {
                items = data.slice(1).map(row => row[0]); // First column for items
                responses = data.slice(1).map(row => row.slice(1)); // Remaining columns for responses
            } else {
                // Horizontal
                items = data[0].slice(1); // First row (from second column) for items
                responses = transposeArray(data.slice(1).map(row => row.slice(1))); // Transpose responses, excluding ID column
            }

            // Populate currentResponseValueMap based on currentScaleOptions order
            currentScaleOptions.forEach((option, index) => {
                currentResponseValueMap[option] = currentScaleOptions.length - index;
            });

            // Auto-detect domains based on the pattern "Domain Name [Item Text]"
            const domainGroups = {};
            const domainNames = []; // Keep track of domain names in order
            
            items.forEach((item, index) => {
                const match = String(item).match(/(.+) \[(.+)\]/);
                let itemText;
                let domainName;
                if (match) {
                    domainName = match[1].trim();
                    itemText = match[2].trim();
                } else {
                    domainName = 'General'; // Default domain for items without a specified domain
                    itemText = String(item).trim();
                }

                if (domainNames.length === 0 || domainNames[domainNames.length - 1] !== domainName) {
                    domainNames.push(domainName);
                }

                if (!domainGroups[domainName]) {
                    domainGroups[domainName] = {
                        items: [],
                        responses: []
                    };
                }

                domainGroups[domainName].items.push(itemText);
                domainGroups[domainName].responses.push(responses[index]);
            });
            
            const domainAverages = []; // To store domain averages for the overall domain table
            const allItemsWithPositives = []; // To collect all items for combined positive lists

            let domainNum = 0;
            domainNames.forEach(domainName => {
                domainNum++;
                const domain = domainGroups[domainName];
                const domainItems = domain.items;
                const domainResponses = domain.responses;

                const tableData = [];
                domainItems.forEach((item, index) => {
                    const itemResponses = domainResponses[index];
                    const frequencies = {};
                    let positivesSum = 0;
                    currentScaleOptions.forEach(option => frequencies[option] = 0);
                    itemResponses.forEach(response => {
                        const trimmedResponse = String(response).trim();
                        if (frequencies.hasOwnProperty(trimmedResponse)) {
                            frequencies[trimmedResponse]++;
                        }
                        if (positiveScaleOptions.has(trimmedResponse)) {
                            positivesSum++;
                        }
                    });
                    const rowData = {
                        item: item,
                        frequencies: frequencies,
                        totalResponses: itemResponses.length,
                        mean: calculateMean(itemResponses),
                        positives: positivesSum
                    };
                    tableData.push(rowData);
                    allItemsWithPositives.push({ item: item, positivesPercentage: itemResponses.length > 0 ? ((positivesSum / itemResponses.length) * 100).toFixed(2) : 0 });
                });

                // Sort table data by mean in descending order
                tableData.sort((a, b) => b.mean - a.mean);

                // Render the table for this domain
                renderTable(tableData, domainName, resultsContainer); // Pass domainName directly as title

                // Calculate domain averages for the domain averages table
                const domainAverageFrequencies = {};
                currentScaleOptions.forEach(option => domainAverageFrequencies[option] = 0);
                tableData.forEach(rowData => {
                    for (const option in rowData.frequencies) {
                        domainAverageFrequencies[option] += rowData.frequencies[option];
                    }
                });
                const domainTotalResponsesInDomain = domainResponses.flat().filter(r => String(r).trim() !== '').length;
                domainAverages.push({
                    domainName: domainName,
                    frequencies: domainAverageFrequencies,
                    totalResponses: domainTotalResponsesInDomain,
                    mean: calculateMean([...domainResponses.flat()])
                });
                const domainChartLabels = Object.keys(domainAverageFrequencies);
                const domainChartDataValues = Object.values(domainAverageFrequencies);
                const domainChartTotalResponses = domainChartDataValues.reduce((sum, val) => sum + val, 0);
                const domainChartPercentages = domainChartDataValues.map(val => domainChartTotalResponses > 0 ? ((val / domainChartTotalResponses) * 100).toFixed(2) : 0);
                const domainDatasets = [{
                    label: 'Percentage',
                    data: domainChartPercentages,
                    backgroundColor: responseColors.slice(0, domainChartLabels.length),
                    borderColor: responseColors.slice(0, domainChartLabels.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                    borderWidth: 1
                }];
                renderChart(domainChartLabels, domainDatasets, `domainChart${domainNum}`, languageData[currentLang].domainChartTitle.replace('{number}', domainName));
            });
            // Render the domain averages table
            renderDomainAveragesTable(domainAverages);

            const positivesThreshold = parseInt(positivesThresholdInput.value, 10);
            const highPositives = allItemsWithPositives.filter(item => item.positivesPercentage >= positivesThreshold);
            const lowPositives = allItemsWithPositives.filter(item => item.positivesPercentage < positivesThreshold);
            renderPositiveItemsLists(highPositives, lowPositives);

            renderOverallDomainAveragesChart(domainAverages);

            // Reorder containers after all rendering is done
            const parentContainer = resultsContainer.parentNode; // This is the max-w-7xl div
            parentContainer.insertBefore(chartContainer, positiveNegativeItemsContainer);

        }

        // Function to process and display results (full questionnaire - legacy function, kept for now)
        function displayFullResults(data) {
            resultsContainer.innerHTML = '';
            chartContainer.innerHTML = '';
            positiveNegativeItemsContainer.innerHTML = '';
            destroyAllCharts();

            let items;
            let responses;
            if (dataOrientation === 'vertical') {
                items = data.slice(1).map(row => row[0]);
                responses = data.slice(1).map(row => row.slice(1));
            } else {
                items = data[0].slice(1);
                responses = transposeArray(data.slice(1).map(row => row.slice(1)));
            }

            const tableData = [];

            const overallFrequencies = {};
            currentScaleOptions.forEach(option => overallFrequencies[option] = 0);
            responses.forEach(itemResponses => {
                itemResponses.forEach(response => {
                    const trimmedResponse = String(response).trim();
                    if (overallFrequencies.hasOwnProperty(trimmedResponse)) {
                        overallFrequencies[trimmedResponse]++;
                    }
                });
            });

            currentScaleOptions.forEach((option, index) => {
                currentResponseValueMap[option] = currentScaleOptions.length - index;
            });

            items.forEach((item, index) => {
                const itemResponses = responses[index];
                const frequencies = {};
                let positivesSum = 0;
                currentScaleOptions.forEach(option => frequencies[option] = 0);
                itemResponses.forEach(response => {
                    const trimmedResponse = String(response).trim();
                    if (frequencies.hasOwnProperty(trimmedResponse)) {
                        frequencies[trimmedResponse]++;
                    }
                    if (positiveScaleOptions.has(trimmedResponse)) {
                        positivesSum++;
                    }
                });
                const rowData = {
                    item: item,
                    frequencies: frequencies,
                    totalResponses: itemResponses.length,
                    mean: calculateMean(itemResponses),
                    positives: positivesSum
                };
                tableData.push(rowData);
            });

            tableData.sort((a, b) => b.mean - a.mean);

            renderTable(tableData, 'full', resultsContainer);

            const positivesThreshold = parseInt(positivesThresholdInput.value, 10);
            const itemsWithPositives = tableData.map(item => ({
                item: item.item,
                positivesPercentage: item.totalResponses > 0 ? ((item.positives / item.totalResponses) * 100) : 0
            }));
            const highPositives = itemsWithPositives.filter(item => item.positivesPercentage >= positivesThreshold);
            const lowPositives = itemsWithPositives.filter(item => item.positivesPercentage < positivesThreshold);
            renderPositiveItemsLists(highPositives, lowPositives);

            const overallChartLabels = Object.keys(overallFrequencies);
            const overallChartDataValues = Object.values(overallFrequencies);
            const overallChartTotalResponses = overallChartDataValues.reduce((sum, val) => sum + val, 0);
            const overallChartPercentages = overallChartDataValues.map(val => overallChartTotalResponses > 0 ? ((val / overallChartTotalResponses) * 100).toFixed(2) : 0);
            const fullResultsDatasets = [{
                label: 'Percentage',
                data: overallChartPercentages,
                backgroundColor: responseColors.slice(0, overallChartLabels.length),
                borderColor: responseColors.slice(0, overallChartLabels.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                borderWidth: 1
            }];
            renderChart(overallChartLabels, fullResultsDatasets, 'fullResultsChart', languageData[currentLang].chartTitle);
            actionButtons.classList.remove('hidden');

            // Reorder containers after all rendering is done
            const parentContainer = resultsContainer.parentNode; // This is the max-w-7xl div
            parentContainer.insertBefore(chartContainer, positiveNegativeItemsContainer);
        }
        
        // Function to create a table dynamically
        function renderTable(tableData, title, container) {
            const domainId = title.replace(/\s+/g, '-');
            const tableDiv = document.createElement('div');
            tableDiv.classList.add('table-container', 'mb-8');
            tableDiv.innerHTML = `
                <h2 class="text-xl font-bold text-center mb-4 text-gray-800">${title}</h2>
                <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                    <table class="min-w-full divide-y divide-gray-200" id="resultsTable-${domainId}">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${languageData[currentLang].tableHeaders.no}</th>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${languageData[currentLang].tableHeaders.item}</th>
                                ${currentScaleOptions.map(option => `<th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${option}</th>`).join('')}
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${languageData[currentLang].tableHeaders.totalColumn}</th>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${languageData[currentLang].tableHeaders.positives}</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200 text-sm text-gray-700">
                            ${tableData.map((row, index) => {
                                let rowPercentagesSum = 0;
                                const cells = currentScaleOptions.map(option => {
                                    const count = row.frequencies[option] || 0;
                                    const percentage = row.totalResponses > 0 ? ((count / row.totalResponses) * 100) : 0;
                                    rowPercentagesSum += percentage;
                                    return `<td class="px-6 py-4 whitespace-nowrap text-left">${percentage.toFixed(2)}%</td>`;
                                }).join('');
                                const positivesPercentage = row.totalResponses > 0 ? ((row.positives / row.totalResponses) * 100) : 0;

                                return `
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-medium">${index + 1}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-medium">${row.item}</td>
                                    ${cells}
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-semibold">${rowPercentagesSum.toFixed(2)}%</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-semibold text-blue-600">${positivesPercentage.toFixed(2)}%</td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                        <tfoot class="bg-gray-100 font-bold">
                            <tr>
                                <td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider" colspan="2">${languageData[currentLang].tableHeaders.totalRowLabel}</td>
                                ${currentScaleOptions.map(option => {
                                    const totalCountForOption = tableData.reduce((sum, row) => sum + (row.frequencies[option] || 0), 0);
                                    const overallTotalResponses = tableData.reduce((sum, row) => sum + row.totalResponses, 0);
                                    const totalPercentage = overallTotalResponses > 0 ? ((totalCountForOption / overallTotalResponses) * 100) : 0;
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${totalPercentage.toFixed(2)}%</td>`;
                                }).join('')}
                                ${(() => {
                                    // Calculate total sum of percentages for the footer row based on currentScaleOptions
                                    let footerTotalSum = 0;
                                    currentScaleOptions.forEach(option => {
                                        const totalCountForOption = tableData.reduce((sum, row) => sum + (row.frequencies[option] || 0), 0);
                                        const overallTotalResponses = tableData.reduce((sum, row) => sum + row.totalResponses, 0);
                                        footerTotalSum += overallTotalResponses > 0 ? ((totalCountForOption / overallTotalResponses) * 100) : 0;
                                    });
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${footerTotalSum.toFixed(2)}%</td>`;
                                })()}
                                ${(() => {
                                    const totalPositivesCount = tableData.reduce((sum, row) => sum + row.positives, 0);
                                    const overallTotalResponses = tableData.reduce((sum, row) => sum + row.totalResponses, 0);
                                    const overallPositivesPercentage = overallTotalResponses > 0 ? ((totalPositivesCount / overallTotalResponses) * 100) : 0;
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${overallPositivesPercentage.toFixed(2)}%</td>`;
                                })()}
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `;
            container.appendChild(tableDiv);
        }

        // Function to create and render the domain averages table
        function renderDomainAveragesTable(domainAverages) {
            const tableDiv = document.createElement('div');
            tableDiv.classList.add('table-container', 'mb-8');
            tableDiv.innerHTML = `
                <h2 class="text-xl font-bold text-center mb-4 text-gray-800">${languageData[currentLang].domainAverages}</h2>
                <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                    <table class="min-w-full divide-y divide-gray-200" id="domainAveragesTable">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">#</th>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">Domain Name</th>
                                ${currentScaleOptions.map(option => `<th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${option}</th>`).join('')}
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${languageData[currentLang].tableHeaders.totalColumn}</th>
                                <th class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">Positives</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200 text-sm text-gray-700">
                            ${domainAverages.map((domain, index) => {
                                const totalPositiveResponses = Array.from(positiveScaleOptions).reduce((sum, option) => sum + (domain.frequencies[option] || 0), 0);
                                const totalResponses = domain.totalResponses;
                                const positivesPercentage = totalResponses > 0 ? ((totalPositiveResponses / totalResponses) * 100) : 0;
                                
                                let rowPercentagesSum = 0;
                                const cells = currentScaleOptions.map(option => {
                                    const count = domain.frequencies[option] || 0;
                                    const percentage = totalResponses > 0 ? ((count / totalResponses) * 100) : 0;
                                    rowPercentagesSum += percentage;
                                    return `<td class="px-6 py-4 whitespace-nowrap text-left">${percentage.toFixed(2)}%</td>`;
                                }).join('');

                                return `
                                <tr>
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-medium">${index + 1}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-medium">${domain.domainName}</td>
                                    ${cells}
                                    <td class="px-6 py-4 whitespace-nowrap text-left font-semibold">${rowPercentagesSum.toFixed(2)}%</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-left">${positivesPercentage.toFixed(2)}%</td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                        <tfoot class="bg-gray-100 font-bold">
                            <tr>
                                <td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider" colspan="2">${languageData[currentLang].tableHeaders.totalRowLabel}</td>
                                ${currentScaleOptions.map(option => {
                                    const avgPercentageForOption = domainAverages.reduce((sum, domain) => {
                                        const totalResponsesInDomain = domain.totalResponses;
                                        const count = domain.frequencies[option] || 0;
                                        return sum + (totalResponsesInDomain > 0 ? (count / totalResponsesInDomain) * 100 : 0);
                                    }, 0) / (domainAverages.length || 1); // Protect against division by zero if domainAverages is empty
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${avgPercentageForOption.toFixed(2)}%</td>`;
                                }).join('')}
                                ${(() => {
                                    let footerTotalSum = 0;
                                    domainAverages.forEach(domain => {
                                        currentScaleOptions.forEach(option => {
                                            const count = domain.frequencies[option] || 0;
                                            const percentage = domain.totalResponses > 0 ? ((count / domain.totalResponses) * 100) : 0;
                                            footerTotalSum += percentage;
                                        });
                                    });
                                    // Average the total sum across domains for the footer total
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${(footerTotalSum / (domainAverages.length || 1)).toFixed(2)}%</td>`;
                                })()}
                                ${(() => {
                                    const overallAvgPositivesPercentage = domainAverages.reduce((sum, domain) => {
                                        const totalPositiveResponses = Array.from(positiveScaleOptions).reduce((pSum, pOption) => pSum + (domain.frequencies[pOption] || 0), 0);
                                        const totalResponses = domain.totalResponses;
                                        return sum + (totalResponses > 0 ? (totalPositiveResponses / totalResponses) * 100 : 0);
                                    }, 0) / (domainAverages.length || 1); // Protect against division by zero if domainAverages is empty
                                    return `<td class="px-6 py-3 text-left text-xs font-bold text-black uppercase tracking-wider">${overallAvgPositivesPercentage.toFixed(2)}%</td>`;
                                })()}
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `;
            resultsContainer.appendChild(tableDiv);
        }

        // Function to render positive and negative items lists
        function renderPositiveItemsLists(highPositives, lowPositives) {
            positiveNegativeItemsContainer.innerHTML = '';
            const positivesThreshold = parseInt(positivesThresholdInput.value, 10);

            const highPositivesDiv = document.createElement('div');
            highPositivesDiv.classList.add('my-8', 'p-6', 'bg-green-50', 'rounded-lg', 'shadow');
            highPositivesDiv.innerHTML = `
                <h3 class="text-xl font-bold text-green-700 mb-4">${languageData[currentLang].positiveItemsTitle} (>= ${positivesThreshold}%)</h3>
                ${highPositives.length > 0 ?
                    `<ul class="list-disc list-inside space-y-2 text-green-800">
                        ${highPositives.map(item => `<li>${item.item}</li>`).join('')}
                    </ul>` :
                    `<p class="text-green-800">No items meet this threshold.</p>`
                }
            `;
            positiveNegativeItemsContainer.appendChild(highPositivesDiv);

            const lowPositivesDiv = document.createElement('div');
            lowPositivesDiv.classList.add('my-8', 'p-6', 'bg-red-50', 'rounded-lg', 'shadow');
            lowPositivesDiv.innerHTML = `
                <h3 class="text-xl font-bold text-red-700 mb-4">${languageData[currentLang].negativeItemsTitle} (< ${positivesThreshold}%)</h3>
                ${lowPositives.length > 0 ?
                    `<ul class="list-disc list-inside space-y-2 text-red-800">
                        ${lowPositives.map(item => `<li>${item.item}</li>`).join('')}
                    </ul>` :
                    `<p class="text-red-800">No items meet this threshold.</p>`
                }
            `;
            positiveNegativeItemsContainer.appendChild(lowPositivesDiv);
        }

        // Function to create and render a Chart.js chart
        function renderChart(labels, datasets, canvasId, title) {
            const chartDiv = document.createElement('div');
            chartDiv.classList.add('p-6', 'bg-gray-50', 'rounded-xl', 'shadow-inner', 'flex', 'flex-col', 'justify-center', 'items-center');
            chartDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-700">${title}</h3>
                <div class="h-64 w-full">
                    <canvas id="${canvasId}"></canvas>
                </div>
            `;
            chartContainer.appendChild(chartDiv);
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (!ctx) {
                console.error(`ERROR: Could not get 2D context for canvas ID: ${canvasId}. Canvas element might not be in DOM or ID is incorrect.`);
                return; // Crucial: Stop execution if context is not available
            }
            const newChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: { // Data labels plugin configuration
                            anchor: 'center', // Changed to center
                            align: 'center',   // Changed to center
                            color: 'black',
                            font: {
                                weight: 'bold'
                            },
                            formatter: (value) => value + '%' // Format as percentage
                        }
                    },
                    scales: {
                        y: {
                            display: false, // Hide y-axis
                        },
                        x: {
                            ticks: {
                                font: {
                                    weight: 'bold' // Make x-axis labels bold
                                }
                            },
                            title: {
                                display: false // Hide x-axis title for these charts
                            }
                        }
                    }
                }
            });
            allCharts[canvasId] = newChart;
        }

        // Function to render a single chart for overall domain averages
        function renderOverallDomainAveragesChart(domainAverages) {
            // Calculate overall average frequencies for each scale option
            const overallAvgFrequencies = {};
            currentScaleOptions.forEach(option => overallAvgFrequencies[option] = 0);
            let totalResponsesAcrossAllDomains = 0;

            domainAverages.forEach(domain => {
                for (const option in domain.frequencies) {
                    if (overallAvgFrequencies.hasOwnProperty(option)) {
                        overallAvgFrequencies[option] += domain.frequencies[option];
                    }
                }
                totalResponsesAcrossAllDomains += domain.totalResponses;
            });

            const overallChartLabels = [];
            const overallChartPercentages = [];

            // Add percentages for each response option
            currentScaleOptions.forEach(option => {
                const count = overallAvgFrequencies[option] || 0;
                const percentage = totalResponsesAcrossAllDomains > 0 ? ((count / totalResponsesAcrossAllDomains) * 100).toFixed(2) : 0;
                overallChartLabels.push(option);
                overallChartPercentages.push(percentage);
            });

            // Calculate overall positive percentage
            let overallTotalPositiveResponses = 0;
            domainAverages.forEach(domain => {
                overallTotalPositiveResponses += Array.from(positiveScaleOptions).reduce((sum, pOption) => sum + (domain.frequencies[pOption] || 0), 0);
            });
            const overallPositivesPercentage = totalResponsesAcrossAllDomains > 0 ? ((overallTotalPositiveResponses / totalResponsesAcrossAllDomains) * 100).toFixed(2) : 0;

            overallChartLabels.push(languageData[currentLang].positiveLabel); // Add "Positive" label
            overallChartPercentages.push(overallPositivesPercentage);


            const datasets = [{
                label: 'Overall Percentage',
                data: overallChartPercentages,
                backgroundColor: responseColors.slice(0, overallChartLabels.length), // Re-use colors, might need more for 'Positive'
                borderColor: responseColors.slice(0, overallChartLabels.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                borderWidth: 1
            }];

            const chartDiv = document.createElement('div');
            chartDiv.classList.add('p-6', 'bg-gray-50', 'rounded-xl', 'shadow-inner', 'flex', 'flex-col', 'justify-center', 'items-center', 'col-span-1', 'md:col-span-2', 'lg:col-span-3');
            chartDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-700">${languageData[currentLang].domainAveragesChartTitle}</h3>
                <div class="h-96 w-full">
                    <canvas id="overallDomainAveragesChart"></canvas>
                </div>
            `;
            chartContainer.appendChild(chartDiv);
            
            const ctx = document.getElementById('overallDomainAveragesChart').getContext('2d');
            if (!ctx) {
                console.error(`ERROR: Could not get 2D context for canvas ID: overallDomainAveragesChart. Canvas element might not be in DOM or ID is incorrect.`);
                return; // Crucial: Stop execution if context is not available
            }
            const newChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: overallChartLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false // Hide legend as there's only one dataset 'Overall Percentage'
                        },
                        datalabels: { // Data labels plugin configuration
                            anchor: 'center', // Changed to center
                            align: 'center',   // Changed to center
                            color: 'black',
                            font: {
                                weight: 'bold'
                            },
                            formatter: (value) => value + '%' // Format as percentage
                        }
                    },
                    scales: {
                        y: {
                            display: false, // Hide y-axis
                        },
                        x: {
                            ticks: {
                                font: {
                                    weight: 'bold' // Make x-axis labels bold
                                }
                            },
                            title: {
                                display: false // Hide x-axis title
                            }
                        }
                    }
                }
            });
            allCharts['overallDomainAveragesChart'] = newChart;
        }

        // Function to destroy all active chart instances
        function destroyAllCharts() {
            for (const chartId in allCharts) {
                if (allCharts[chartId]) {
                    allCharts[chartId].destroy();
                }
            }
            allCharts = {}; // Reset the object
        }

        // Function to calculate the mean of a set of responses
        function calculateMean(responses) {
            if (!responses || responses.length === 0) return 0;

            let sum = 0;
            let validResponsesCount = 0;
            responses.forEach(response => {
                const trimmedResponse = String(response).trim();
                const value = currentResponseValueMap[trimmedResponse];
                if (value !== undefined) {
                    sum += value;
                    validResponsesCount++;
                }
            });
            return validResponsesCount > 0 ? (sum / validResponsesCount) : 0;
        }
        
        // Event listener for data orientation toggle
        dataOrientationToggle.addEventListener('click', (e) => {
            if (e.target.id === 'orientation-vertical') {
                dataOrientation = 'vertical';
            } else if (e.target.id === 'orientation-horizontal') {
                dataOrientation = 'horizontal';
            }
            updateOrientationButtonStyles();
        });

        function updateOrientationButtonStyles() {
            if (dataOrientation === 'vertical') {
                orientationVerticalSpan.classList.add('bg-indigo-600', 'text-white');
                orientationVerticalSpan.classList.remove('bg-gray-100', 'text-gray-800');
                orientationHorizontalSpan.classList.remove('bg-indigo-600', 'text-white');
                orientationHorizontalSpan.classList.add('bg-gray-100', 'text-gray-800');
            } else {
                orientationHorizontalSpan.classList.add('bg-indigo-600', 'text-white');
                orientationHorizontalSpan.classList.remove('bg-gray-100', 'text-gray-800');
                orientationVerticalSpan.classList.remove('bg-indigo-600', 'text-white');
                orientationVerticalSpan.classList.add('bg-gray-100', 'text-gray-800');
            }
        }
        updateOrientationButtonStyles();

        // Event listener for language toggle
        langToggle.addEventListener('click', (e) => {
            if (e.target.id === 'lang-en') {
                currentLang = 'en';
                document.documentElement.lang = 'en';
                document.documentElement.dir = 'ltr';
            } else if (e.target.id === 'lang-ar') {
                currentLang = 'ar';
                document.documentElement.lang = 'ar';
                document.documentElement.dir = 'rtl';
            }
            updateLanguageUI();
        });

        // Function to update all UI text based on the current language
        function updateLanguageUI() {
            const data = languageData[currentLang];
            document.getElementById('mainTitle').textContent = data.title;
            document.getElementById('subtitle').textContent = data.subtitle;
            document.getElementById('fileButtonText').textContent = data.fileButton;
            document.getElementById('loadingMessage').textContent = data.loading;
            document.getElementById('analyzeButton').textContent = data.analyzeButton;
            document.getElementById('exportButton').textContent = data.exportButton;
            document.getElementById('copyTableButton').textContent = data.copyTableButton;
            document.getElementById('dataOrientationLabel').textContent = data.dataOrientationLabel;
            document.getElementById('orientation-vertical').textContent = data.orientationVertical;
            document.getElementById('orientation-horizontal').textContent = data.orientationHorizontal;
            document.getElementById('scaleOrderTitle').textContent = data.scaleOrderTitle;
            document.getElementById('scaleOrderSubtitle').textContent = data.scaleOrderSubtitle;
            document.getElementById('showVerticalTemplateBtn').textContent = data.templateButtons.vertical;
            document.getElementById('showHorizontalTemplateBtn').textContent = data.templateButtons.horizontal;
            document.getElementById('templateGuideTitle').textContent = data.templateGuide.title;
            document.getElementById('verticalTemplateDescription').textContent = data.templateGuide.verticalDesc;
            document.getElementById('horizontalTemplateDescription').textContent = data.templateGuide.horizontalDesc;
            document.getElementById('vtHeaderItem').textContent = data.templateGuide.vtHeaderItem;
            document.getElementById('vtHeaderResp1').textContent = data.templateGuide.vtHeaderResp;
            document.getElementById('vtHeaderResp2').textContent = data.templateGuide.vtHeaderResp;
            document.getElementById('htHeaderEmpty').textContent = data.templateGuide.htHeaderEmpty;
            document.getElementById('htHeaderItem1').textContent = data.templateGuide.htHeaderItem;
            document.getElementById('htHeaderItem2').textContent = data.templateGuide.htHeaderItem;
            document.getElementById('htRow1Resp').textContent = data.templateGuide.htRowResp;

            updateLangButtonStyles();
            renderScaleOptions(); // Re-render to update positive labels
        }

        function updateLangButtonStyles() {
            if (currentLang === 'en') {
                langEnSpan.classList.add('bg-indigo-600', 'text-white');
                langEnSpan.classList.remove('bg-gray-100', 'text-gray-800');
                langArSpan.classList.remove('bg-indigo-600', 'text-white');
                langArSpan.classList.add('bg-gray-100', 'text-gray-800');
            } else {
                langArSpan.classList.add('bg-indigo-600', 'text-white');
                langArSpan.classList.remove('bg-gray-100', 'text-gray-800');
                langEnSpan.classList.remove('bg-indigo-600', 'text-white');
                langEnSpan.classList.add('bg-gray-100', 'text-gray-800');
            }
        }

        // Function to render the scale order options
        function renderScaleOptions() {
            scaleOrderOptionsContainer.innerHTML = '';
            currentScaleOptions.forEach((option, index) => {
                const isPositive = positiveScaleOptions.has(option);
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('ranking-option');
                optionDiv.draggable = true;
                optionDiv.dataset.option = option;
                optionDiv.innerHTML = `
                    <span class="ranking-option-text">${option}</span>
                    <div class="ranking-option-buttons">
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" class="sr-only peer positive-checkbox" ${isPositive ? 'checked' : ''} data-option="${option}">
                            <div class="relative w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                            <span class="ms-2 text-sm font-medium text-gray-900 dark:text-gray-300">${languageData[currentLang].positiveLabel}</span>
                        </label>
                        <button class="remove-button" data-action="remove">&times;</button>
                        <button class="move-button" data-action="up">&#x25B2;</button>
                        <button class="move-button" data-action="down">&#x25BC;</button>
                    </div>
                `;
                scaleOrderOptionsContainer.appendChild(optionDiv);
            });
        }

        // Event listeners for the Ranking Widget
        scaleOrderOptionsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            const checkbox = e.target.closest('.positive-checkbox');

            if (checkbox) {
                const optionText = checkbox.dataset.option;
                if (checkbox.checked) {
                    positiveScaleOptions.add(optionText);
                } else {
                    positiveScaleOptions.delete(optionText);
                }
            } else if (button) {
                const optionDiv = button.closest('.ranking-option');
                const option = optionDiv.dataset.option;
                const action = button.dataset.action;
                const index = currentScaleOptions.indexOf(option);

                if (action === 'remove') {
                    currentScaleOptions.splice(index, 1);
                    positiveScaleOptions.delete(option); // Also remove from positive set
                } else if (action === 'up' && index > 0) {
                    [currentScaleOptions[index], currentScaleOptions[index - 1]] = [currentScaleOptions[index - 1], currentScaleOptions[index]];
                } else if (action === 'down' && index < currentScaleOptions.length - 1) {
                    [currentScaleOptions[index], currentScaleOptions[index + 1]] = [currentScaleOptions[index + 1], currentScaleOptions[index]];
                }
                renderScaleOptions(); // Re-render the list to reflect changes
            }
        });

        // Drag and drop for ranking options
        let draggedOption = null;
        scaleOrderOptionsContainer.addEventListener('dragstart', (e) => {
            draggedOption = e.target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.option);
            setTimeout(() => {
                draggedOption.classList.add('opacity-50');
            }, 0);
        });
        scaleOrderOptionsContainer.addEventListener('dragend', (e) => {
            draggedOption.classList.remove('opacity-50');
            draggedOption = null;
        });
        scaleOrderOptionsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            const target = e.target.closest('.ranking-option');
            if (target && target !== draggedOption) {
                const targetRect = target.getBoundingClientRect();
                const draggedRect = draggedOption.getBoundingClientRect();
                if (e.clientY < targetRect.top + targetRect.height / 2) {
                    scaleOrderOptionsContainer.insertBefore(draggedOption, target);
                } else {
                    scaleOrderOptionsContainer.insertBefore(draggedOption, target.nextSibling);
                }
            }
        });
        scaleOrderOptionsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const droppedOption = e.dataTransfer.getData('text/plain');
            const newOrder = Array.from(scaleOrderOptionsContainer.children).map(child => child.dataset.option);
            currentScaleOptions = newOrder;
        });


        // Event listener for Export to XLSX button
        exportButton.addEventListener('click', () => {
            const allTables = document.querySelectorAll('#resultsContainer .table-container table');
            if (allTables.length === 0) {
                showMessage('No data to export.', 'error');
                return;
            }

            const workbook = XLSX.utils.book_new();
            const sheetData = [];

            // Add filename and participant count at the top of the export
            if (!fileNameDisplay.classList.contains('hidden')) {
                sheetData.push([fileNameDisplay.textContent]);
                sheetData.push([]); // Spacer
            }
            if (!participantCountDisplay.classList.contains('hidden')) {
                sheetData.push([participantCountDisplay.textContent]);
                sheetData.push([]); // Spacer
            }

            allTables.forEach(table => {
                const titleElement = table.closest('.table-container').querySelector('h2');
                const tableTitle = titleElement ? titleElement.textContent.trim() : 'Table';
                
                // Add table title as a row
                sheetData.push([tableTitle]);
                sheetData.push([]); // Empty row for spacing

                // Get table headers
                const headerRow = [];
                Array.from(table.querySelectorAll('thead th')).forEach(th => {
                    headerRow.push(th.textContent.replace(' (%)', '')); // Remove (%) from headers for export
                });
                sheetData.push(headerRow);

                // Get table body rows
                Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
                    const rowData = [];
                    Array.from(tr.querySelectorAll('td')).forEach(td => {
                        rowData.push(td.textContent);
                    });
                    sheetData.push(rowData);
                });

                // Get table footer row (if exists)
                const tfoot = table.querySelector('tfoot');
                if (tfoot) {
                    Array.from(tfoot.querySelectorAll('tr')).forEach(tr => {
                        const footerRowData = [];
                        Array.from(tr.querySelectorAll('td')).forEach(td => {
                            footerRowData.push(td.textContent.replace(' (%)', '')); // Remove (%) from headers for export
                        });
                        sheetData.push(footerRowData);
                    });
                }
                sheetData.push([]); // Empty row for spacing between tables
                sheetData.push([]); // Another empty row for more spacing
            });

            // Add the positive and negative items to the export
            const highPositivesDiv = document.querySelector('#positiveNegativeItemsContainer .bg-green-50');
            const lowPositivesDiv = document.querySelector('#positiveNegativeItemsContainer .bg-red-50');

            if (highPositivesDiv) {
                sheetData.push([highPositivesDiv.querySelector('h3').textContent]);
                // Iterate over list items and add their text content
                Array.from(highPositivesDiv.querySelectorAll('li')).forEach(li => sheetData.push([li.textContent]));
                sheetData.push([]); // Spacer
            }
            if (lowPositivesDiv) {
                sheetData.push([lowPositivesDiv.querySelector('h3').textContent]);
                // Iterate over list items and add their text content
                Array.from(lowPositivesDiv.querySelectorAll('li')).forEach(li => sheetData.push([li.textContent]));
                sheetData.push([]); // Spacer
            }

            if (sheetData.length > 0) {
                const ws = XLSX.utils.aoa_to_sheet(sheetData);
                XLSX.utils.book_append_sheet(workbook, ws, 'Analysis Results');
            }

            // Write and save the file
            XLSX.writeFile(workbook, 'questionnaire-analysis-results.xlsx');
        });


        // Event listener for Copy All Tables button
        copyTableButton.addEventListener('click', () => {
            const allTables = document.querySelectorAll('#resultsContainer .table-container table');
            let combinedText = '';

            // Add filename and participant count at the top of the copied text
            if (!fileNameDisplay.classList.contains('hidden')) {
                combinedText += fileNameDisplay.textContent + '\n\n';
            }
            if (!participantCountDisplay.classList.contains('hidden')) {
                combinedText += participantCountDisplay.textContent + '\n\n';
            }


            allTables.forEach(table => {
                const titleElement = table.closest('.table-container').querySelector('h2');
                const tableTitle = titleElement ? titleElement.textContent.trim() : 'Table';
                combinedText += titleElement + '\n\n'; // Add title

                // Get headers
                Array.from(table.querySelectorAll('thead th')).forEach((th, index) => {
                    combinedText += th.textContent.replace(' (%)', '') + (index < table.querySelectorAll('thead th').length - 1 ? '\t' : '');
                });
                combinedText += '\n';

                // Get body rows
                Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
                    Array.from(tr.querySelectorAll('td')).forEach((td, index) => {
                        combinedText += td.textContent + (index < tr.querySelectorAll('td').length - 1 ? '\t' : '');
                    });
                    combinedText += '\n';
                });

                // Get footer row (if exists)
                const tfoot = table.querySelector('tfoot');
                if (tfoot) {
                    Array.from(tfoot.querySelectorAll('tr')).forEach(tr => {
                        Array.from(tr.querySelectorAll('td')).forEach((td, index) => {
                            combinedText += td.textContent.replace(' (%)', '') + (index < tr.querySelectorAll('td').length - 1 ? '\t' : '');
                        });
                        combinedText += '\n';
                    });
                }
                combinedText += '\n\n'; // Add spacing between tables
            });

            // Add positive and negative items
            const highPositivesDiv = document.querySelector('#positiveNegativeItemsContainer .bg-green-50');
            const lowPositivesDiv = document.querySelector('#positiveNegativeItemsContainer .bg-red-50');

            if (highPositivesDiv) {
                combinedText += highPositivesDiv.querySelector('h3').textContent + '\n';
                Array.from(highPositivesDiv.querySelectorAll('li')).forEach(li => combinedText += li.textContent + '\n');
                combinedText += '\n';
            }
            if (lowPositivesDiv) {
                combinedText += lowPositivesDiv.querySelector('h3').textContent + '\n';
                Array.from(lowPositivesDiv.querySelectorAll('li')).forEach(li => combinedText += li.textContent + '\n');
                combinedText += '\n';
            }

            // Use document.execCommand('copy') for copying as it's more reliable in iframes
            const textArea = document.createElement("textarea");
            textArea.value = combinedText;
            textArea.style.position = "fixed"; // Avoid scrolling to bottom
            textArea.style.left = "-999999px"; // Move off-screen
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage(languageData[currentLang].tableCopied, 'info');
                } else {
                    showMessage('Failed to copy tables. Please try again or use the Export button.', 'error');
                }
            } catch (err) {
                    console.error('Failed to copy tables (execCommand):', err);
                    showMessage('Failed to copy tables. Please try again or use the Export button.', 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        });

        // Event listeners for template guide buttons
        showVerticalTemplateBtn.addEventListener('click', () => {
            templateGuideContainer.classList.remove('hidden');
            verticalTemplateContent.classList.remove('hidden');
            horizontalTemplateContent.classList.add('hidden');
            // Update table headers in guide
            document.getElementById('vtHeaderItem').textContent = languageData[currentLang].templateGuide.vtHeaderItem;
            document.getElementById('vtHeaderResp1').textContent = languageData[currentLang].templateGuide.vtHeaderResp;
            document.getElementById('vtHeaderResp2').textContent = languageData[currentLang].templateGuide.vtHeaderResp; 
        });

        showHorizontalTemplateBtn.addEventListener('click', () => {
            templateGuideContainer.classList.remove('hidden');
            horizontalTemplateContent.classList.remove('hidden');
            verticalTemplateContent.classList.add('hidden');
            // Update table headers in guide
            document.getElementById('htHeaderEmpty').textContent = languageData[currentLang].templateGuide.htHeaderEmpty;
            document.getElementById('htHeaderItem1').textContent = languageData[currentLang].templateGuide.htHeaderItem;
            document.getElementById('htHeaderItem2').textContent = languageData[currentLang].templateGuide.htHeaderItem;
        });

        closeTemplateGuideBtn.addEventListener('click', () => {
            templateGuideContainer.classList.add('hidden');
        });

        // Initialize UI with default language
        updateLanguageUI();
        updateLangButtonStyles();
    });
    </script>
</body>
</html>
