<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questionnaire Results Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include SheetJS and Chart.js libraries -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e5e7eb;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        /* Fix for table header cells */
        #resultsTable th {
            white-space: nowrap;
        }
        .ranking-option {
            display: flex;
            align-items: center;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .ranking-option-text {
            flex-grow: 1;
            font-weight: 500;
            color: #374151;
        }
        .ranking-option-buttons {
            display: flex;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        .ranking-option-buttons button {
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .ranking-option-buttons .move-button {
            background-color: #a78bfa; /* Purple 400 */
            color: white;
        }
        .ranking-option-buttons .move-button:hover {
            background-color: #8b5cf6; /* Purple 500 */
        }
        .ranking-option-buttons .remove-button {
            background-color: #ef4444; /* Red 500 */
            color: white;
        }
        .ranking-option-buttons .remove-button:hover {
            background-color: #dc2626; /* Red 600 */
        }
    </style>
</head>
<body class="p-6 md:p-12">
    <!-- Language switch button container with fixed position -->
    <div style="position: fixed; top: 1.5rem; left: 1.5rem; z-index: 100;" class="flex flex-col space-y-2">
        <div id="langToggle" class="flex rounded-lg shadow-md overflow-hidden cursor-pointer transition-colors duration-300">
            <span id="lang-en" class="px-6 py-3 font-semibold transition-colors duration-300">English</span>
            <span id="lang-ar" class="px-6 py-3 font-semibold transition-colors duration-300">العربية</span>
        </div>
        <!-- New template buttons -->
        <div class="flex space-x-2">
            <button id="showVerticalTemplateBtn" class="px-4 py-2 bg-gray-300 text-gray-800 text-sm font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-300">
                Vertical Template
            </button>
            <button id="showHorizontalTemplateBtn" class="px-4 py-2 bg-gray-300 text-gray-800 text-sm font-semibold rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-300">
                Horizontal Template
            </button>
        </div>
    </div>

    <!-- Logo at the top right -->
    <div style="position: fixed; top: 1.5rem; right: 1.5rem; z-index: 100;">
        <img src="https://placehold.co/80x80/ffffff/000000?text=Logo" alt="Logo" class="h-20 w-20 shadow-md rounded-full">
    </div>
    <div class="max-w-7xl mx-auto bg-white p-8 rounded-2xl shadow-xl">
        <h1 id="mainTitle" class="text-3xl font-bold text-center mb-1 text-gray-800">Questionnaire Results Analysis</h1>
        <p class="text-center text-gray-600 mb-6 text-sm" id="developerCredit">Developed by Dr. Mazen Badawy – Doctorate of English Teaching & Testing</p>
        <p id="subtitle" class="text-center text-gray-600 mb-8">Upload your Excel (XLSX) file with the questionnaire results to view the analysis.</p>
        <!-- Data Orientation switch button -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <p id="dataOrientationLabel" class="text-gray-700 font-semibold">Data Orientation:</p>
            <div id="dataOrientationToggle" class="flex rounded-lg shadow-md overflow-hidden cursor-pointer transition-colors duration-300">
                <span id="orientation-vertical" class="px-6 py-3 font-semibold transition-colors duration-300">Vertical</span>
                <span id="orientation-horizontal" class="px-6 py-3 font-semibold transition-colors duration-300">Horizontal</span>
            </div>
        </div>
        <!-- New section for item trimming option -->
        <div class="flex flex-col items-center space-y-2 mb-8">
            <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="trimItemsToggle" class="sr-only peer">
                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-indigo-600"></div>
                <span id="trimItemsLabel" class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">Trim Questionnaire Items (keep text in [ ])</span>
            </label>
        </div>

        <!-- File input and loading indicator -->
        <div id="fileUploadSection" class="flex flex-col items-center space-y-4 mb-8">
            <label for="xlsxFile" class="block w-full text-center">
                <span id="fileButtonText" class="inline-block px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition-colors duration-300 cursor-pointer">
                    Choose XLSX File
                </span>
                <input type="file" id="xlsxFile" class="hidden" accept=".xlsx, .xls">
            </label>
            <div id="loadingMessage" class="hidden text-gray-500">
                Processing data, please wait...
            </div>
            <!-- Message Box for errors -->
            <div id="messageBox" class="hidden bg-red-100 border-r-4 border-red-500 text-red-700 p-4 w-full rounded-md" role="alert">
                <div class="flex items-center">
                    <svg class="h-6 w-6 text-red-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold" id="messageTitle">Error!</p>
                        <p id="messageText" class="text-sm"></p>
                    </div>
                </div>
            </div>
        </div>
        <!-- New section for scale order definition (Ranking Widget) -->
        <div id="scaleOrderSection" class="hidden w-full max-w-2xl mx-auto mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
            <h2 id="scaleOrderTitle" class="text-xl font-bold text-gray-700 mb-4">Define Scale Order (Ranking Widget)</h2>
            <p id="scaleOrderSubtitle" class="text-gray-600 mb-4">Arrange the automatically recognized response categories in the desired order (highest value at the top).</p>
            <div id="scaleOrderOptionsContainer" class="space-y-2">
                <!-- Ranking options will be dynamically inserted here -->
            </div>
            <!-- Message Box for scale order errors -->
            <div id="scaleOrderMessageBox" class="hidden bg-red-100 border-r-4 border-red-500 text-red-700 p-4 w-full rounded-md mt-4" role="alert">
                <div class="flex items-center">
                    <svg class="h-6 w-6 text-red-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold" id="scaleOrderMessageTitle">Error!</p>
                        <p id="scaleOrderMessageText" class="text-sm"></p>
                    </div>
                </div>
            </div>
        </div>
        <!-- New section for domain analysis -->
        <div id="domainSection" class="hidden w-full max-w-2xl mx-auto mb-8 p-6 bg-gray-50 rounded-lg shadow-inner">
            <h2 id="domainTitle" class="text-xl font-bold text-gray-700 mb-4">Define Domains (Optional)</h2>
            <p id="domainSubtitle" class="text-gray-600 mb-4">Enter the number of items for each domain, separated by commas (e.g., 5, 3, 7).</p>
            <p id="totalItemsDisplay" class="text-gray-700 font-semibold mb-4"></p>
            <div class="flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4 space-x-reverse:rtl md:space-x-reverse:ltr">
                <input type="text" id="domainInput" class="flex-1 w-full md:w-auto px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., 5, 3, 7">
            </div>
            <!-- Message Box for domain errors -->
            <div id="domainMessageBox" class="hidden bg-red-100 border-r-4 border-red-500 text-red-700 p-4 w-full rounded-md mt-4" role="alert">
                <div class="flex items-center">
                    <svg class="h-6 w-6 text-red-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold" id="domainMessageTitle">Error!</p>
                        <p id="domainMessageText" class="text-sm"></p>
                    </div>
                </div>
            </div>
        </div>
        <!-- Action buttons container -->
        <div id="actionButtons" class="hidden flex flex-row justify-center space-x-4 space-x-reverse:rtl mb-8">
            <button id="analyzeButton" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300">
                Analyze Data
            </button>
            <button id="exportButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300">
                Export to XLSX
            </button>
            <button id="copyTableButton" class="px-6 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700 transition-colors duration-300">
                Copy Table
            </button>
        </div>

        <!-- The results table container -->
        <div id="resultsContainer" class="hidden overflow-x-auto">
            <!-- Tables for each domain will be injected here -->
        </div>
        <!-- Sections for Positive and Negative Items -->
        <div id="positiveNegativeItemsContainer" class="hidden">
            <!-- These divs will be dynamically injected by renderPositiveItemsLists -->
        </div>
        <!-- Charts container -->
        <div id="chartContainer" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-8">
            <!-- Charts will be injected here -->
            <div class="p-6 bg-gray-50 rounded-xl shadow-inner flex flex-col justify-center items-center">
                <h3 class="text-lg font-semibold mb-4 text-gray-700" id="fullChartTitle"></h3>
                <div class="h-64 w-full">
                    <canvas id="fullResultsChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    <!-- Template Guide Container (initially hidden) -->
    <div id="templateGuideContainer" class="hidden fixed top-28 left-12 z-10 bg-white p-6 rounded-lg shadow-xl border border-gray-200 w-96 max-w-full">
        <div class="flex justify-between items-center mb-4">
            <h3 id="templateGuideTitle" class="text-lg font-bold text-gray-800"></h3>
            <button id="closeTemplateGuideBtn" class="text-gray-500 hover:text-gray-700 font-bold text-xl">&times;</button>
        </div>
        <div id="verticalTemplateContent" class="hidden">
            <p id="verticalTemplateDescription" class="text-gray-600 mb-2 text-sm"></p>
            <table class="w-full text-sm text-left text-gray-700 border border-gray-300 rounded-md overflow-hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="px-3 py-2 border-r border-b" id="vtHeaderItem"></th>
                        <th class="px-3 py-2 border-r border-b" id="vtHeaderResp1"></th>
                        <th class="px-3 py-2 border-b" id="vtHeaderResp2"></th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="px-3 py-2 border-r border-b">Question 1</td>
                        <td class="px-3 py-2 border-r border-b">Agree</td>
                        <td class="px-3 py-2 border-b">Disagree</td>
                    </tr>
                    <tr>
                        <td class="px-3 py-2 border-r">Question 2</td>
                        <td class="px-3 py-2 border-r">Neutral</td>
                        <td class="px-3 py-2">Agree</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="horizontalTemplateContent" class="hidden">
            <p id="horizontalTemplateDescription" class="text-gray-600 mb-2 text-sm"></p>
            <table class="w-full text-sm text-left text-gray-700 border border-gray-300 rounded-md overflow-hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="px-3 py-2 border-r border-b" id="htHeaderEmpty"></th>
                        <th class="px-3 py-2 border-r border-b" id="htHeaderItem1"></th>
                        <th class="px-3 py-2 border-b" id="htHeaderItem2"></th>
                        </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="px-3 py-2 border-r border-b" id="htRow1Resp">Respondent 1</td>
                        <td class="px-3 py-2 border-r border-b">Agree</td>
                        <td class="px-3 py-2 border-b">Neutral</td>
                    </tr>
                    <tr>
                        <td class="px-3 py-2 border-r">Respondent 2</td>
                        <td class="px-3 py-2 border-r">Disagree</td>
                        <td class="px-3 py-2">Agree</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', (event) => {
        // Get references to DOM elements
        const xlsxFile = document.getElementById('xlsxFile');
        const fileUploadSection = document.getElementById('fileUploadSection');
        const loadingMessage = document.getElementById('loadingMessage');
        const resultsContainer = document.getElementById('resultsContainer');
        const chartContainer = document.getElementById('chartContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const exportButton = document.getElementById('exportButton');
        const copyTableButton = document.getElementById('copyTableButton');
        const langToggle = document.getElementById('langToggle');
        const langEnSpan = document.getElementById('lang-en');
        const langArSpan = document.getElementById('lang-ar');
        const domainSection = document.getElementById('domainSection');
        const domainInput = document.getElementById('domainInput');
        const analyzeButton = document.getElementById('analyzeButton');
        const actionButtons = document.getElementById('actionButtons');
        const totalItemsDisplay = document.getElementById('totalItemsDisplay');
        const positiveNegativeItemsContainer = document.getElementById('positiveNegativeItemsContainer'); // New container

        // Data orientation elements
        const dataOrientationToggle = document.getElementById('dataOrientationToggle');
        const orientationVerticalSpan = document.getElementById('orientation-vertical');
        const orientationHorizontalSpan = document.getElementById('orientation-horizontal');
        const dataOrientationLabel = document.getElementById('dataOrientationLabel');

        // Scale order (Ranking Widget) elements
        const scaleOrderSection = document.getElementById('scaleOrderSection');
        const scaleOrderOptionsContainer = document.getElementById('scaleOrderOptionsContainer');
        const scaleOrderMessageBox = document.getElementById('scaleOrderMessageBox');
        const scaleOrderMessageText = document.getElementById('scaleOrderMessageText');
        const scaleOrderMessageTitle = document.getElementById('scaleOrderMessageTitle');

        // Domain message box elements (added missing references)
        const domainMessageBox = document.getElementById('domainMessageBox');
        const domainMessageText = document.getElementById('domainMessageText');
        const domainMessageTitle = document.getElementById('domainMessageTitle');

        // Item trimming elements
        const trimItemsToggle = document.getElementById('trimItemsToggle'); // New element
        const trimItemsLabel = document.getElementById('trimItemsLabel');   // New element
        let enableItemTrimming = false; // New variable

        // Template buttons and guide elements
        const showVerticalTemplateBtn = document.getElementById('showVerticalTemplateBtn');
        const showHorizontalTemplateBtn = document.getElementById('showHorizontalTemplateBtn');
        const templateGuideContainer = document.getElementById('templateGuideContainer');
        const closeTemplateGuideBtn = document.getElementById('closeTemplateGuideBtn');
        const templateGuideTitle = document.getElementById('templateGuideTitle');
        const verticalTemplateContent = document.getElementById('verticalTemplateContent');
        const horizontalTemplateContent = document.getElementById('horizontalTemplateContent');

        // Define language data for easy switching
        const languageData = {
            en: {
                title: 'Questionnaire Results Analysis',
                subtitle: 'Upload your Excel (XLSX) file with the questionnaire results to view the analysis.',
                fileButton: 'Choose XLSX File',
                loading: 'Processing data, please wait...',
                error: 'Error!',
                fileError: 'Please select an Excel (XLSX) file.',
                parseError: 'An error occurred while processing the file. Please ensure it is a valid Excel (XLSX) file.',
                emptyFile: 'The file is empty or contains only one row.',
                langButton: 'العربية',
                exportButton: 'Export to XLSX',
                copyTableButton: 'Copy Table',
                tableCopied: 'Table copied to clipboard!',
                analyzeButton: 'Analyze Data',
                domainTitle: 'Define Domains (Optional)',
                domainSubtitle: 'Enter the number of items for each domain, separated by commas (e.g., 5, 3, 7).',
                totalItemsDisplay: 'Total items identified: {total}',
                domainNumber: 'Domain {number}',
                domainAverages: 'Domain Averages',
                domainItemsError: 'The total number of items specified ({sum}) does not match the total number of items in the file ({total}).',
                tableHeaders: {
                    no: 'No.',
                    item: 'Item',
                    positives: 'Positives', // New header
                    totalColumn: 'Total', // For the 100% column
                    totalRowLabel: 'Totals', // For the footer row
                    totalPercentageLabel: 'Overall Percentage Sum' // For the 100% check text
                },
                chartTitle: 'Percentage Distribution of Responses',
                domainChartTitle: 'Percentage Distribution for Domain {number}',
                domainAveragesChartTitle: 'Average Percentage Distribution Across All Domains', // Changed chart title
                dataOrientationLabel: 'Data Orientation:',
                orientationVertical: 'Vertical',
                orientationHorizontal: 'Horizontal',
                scaleOrderTitle: 'Define Scale Order (Ranking Widget)',
                scaleOrderSubtitle: 'Arrange the automatically recognized response categories in the desired order (highest value at the top).',
                scaleOrderEmpty: 'Please add at least one response category.',
                scaleOrderDuplicate: 'Duplicate response category found. Please ensure all categories are unique.',
                trimItemsLabel: 'Trim Questionnaire Items (keep text in [ ])', // New translation
                positiveLabel: 'Positive', // New translation
                templateButtons: {
                    vertical: 'Vertical Template',
                    horizontal: 'Horizontal Template'
                },
                templateGuide: {
                    title: 'XLSX File Template Guide',
                    verticalDesc: 'For Vertical data, items are in Column A, and responses start from Column B:',
                    horizontalDesc: 'For Horizontal data, items are in Row 1, and responses start from Row 2:',
                    vtHeaderItem: 'Item Name',
                    vtHeaderResp: 'Response',
                    htHeaderEmpty: 'ID/Empty',
                    htHeaderItem: 'Item',
                    htRowResp: 'Respondent'
                },
                positiveItemsTitle: 'Negative Items', // Renamed title
                negativeItemsTitle: 'Positive Items' // Renamed title
            },
            ar: {
                title: 'تحليل نتائج الاستبيان',
                subtitle: 'قم بتحميل ملف Excel (XLSX) الخاص بنتائج الاستبيان لعرض التحليل.',
                fileButton: 'اختر ملف XLSX',
                loading: 'جاري تحميل وتحليل البيانات، يرجى الانتظار...',
                error: 'خطأ!',
                fileError: 'يرجى تحديد ملف Excel (XLSX).',
                parseError: 'حدث خطأ أثناء معالجة الملف. يرجى التأكد من أنه ملف Excel (XLSX) صحيح.',
                emptyFile: 'الملف فارغ أو يحتوي على صف واحد فقط.',
                langButton: 'English',
                exportButton: 'تصدير إلى XLSX',
                copyTableButton: 'نسخ الجدول',
                tableCopied: 'تم نسخ الجدول إلى الحافظة!',
                analyzeButton: 'تحليل البيانات',
                domainTitle: 'تحديد المجالات (اختياري)',
                domainSubtitle: 'أدخل عدد البنود لكل مجال، مفصولة بفواصل (مثال: 5, 3, 7).',
                totalItemsDisplay: 'إجمالي البنود المحددة: {total}',
                domainNumber: 'المجال {number}',
                domainAverages: 'متوسطات المجال',
                domainItemsError: 'مجموع البنود المحددة ({sum}) لا يتطابق مع العدد الإجمالي للبنود في الملف ({total}).',
                tableHeaders: {
                    no: 'الرقم',
                    item: 'العناصر',
                    positives: 'الإيجابيات', // New header
                    totalColumn: 'الإجمالي', // For the 100% column
                    totalRowLabel: 'المجاميع', // For the footer row
                    totalPercentageLabel: 'المجموع الكلي للنسب المئوية' // For the 100% check text
                },
                chartTitle: 'توزيع الاستجابات بالنسبة المئوية',
                domainChartTitle: 'توزيع الاستجابات بالنسبة المئوية للمجال {number}',
                domainAveragesChartTitle: 'متوسط توزيع النسبة المئوية عبر جميع المجالات', // Changed chart title
                dataOrientationLabel: 'اتجاه البيانات:',
                orientationVertical: 'عمودي',
                orientationHorizontal: 'أفقي',
                scaleOrderTitle: 'تحديد ترتيب المقياس (أداة الترتيب)',
                scaleOrderSubtitle: 'أضف فئات الاستجابة وقم بترتيبها بالترتيب المطلوب (أعلى قيمة في الأعلى).',
                scaleOrderEmpty: 'الرجاء إضافة فئة استجابة واحدة على الأقل.',
                scaleOrderDuplicate: 'تم العثور على فئة استجابة مكررة. يرجى التأكد من أن جميع الفئات فريدة.',
                trimItemsLabel: 'قص بنود الاستبيان (الاحتفاظ بالنص داخل [ ])', // New translation
                positiveLabel: 'إيجابي', // New translation
                templateButtons: {
                    vertical: 'قالب عمودي',
                    horizontal: 'قالب أفقي'
                },
                templateGuide: {
                    title: 'دليل قالب ملف XLSX',
                    verticalDesc: 'للبيانات العمودية، تكون البنود في العمود A، وتبدأ الاستجابات من العمود B:',
                    horizontalDesc: 'للبيانات الأفقية، تكون البنود في الصف 1، وتبدأ الاستجابات من الصف 2:',
                    vtHeaderItem: 'اسم البند',
                    vtHeaderResp: 'الاستجابة',
                    htHeaderEmpty: 'المعرف/فارغ',
                    htHeaderItem: 'البند',
                    htRowResp: 'المستجيب'
                },
                positiveItemsTitle: 'البنود الإيجابية', // Renamed title
                negativeItemsTitle: 'البنود السلبية' // Renamed title
            }
        };

        // Define a default mapping for Likert scale responses to numerical values.
        const defaultResponseValueMap = {
            'أوافق تماما': 5,
            'أوافق': 4,
            'أوافق إلي حد ما': 3,
            'لا أوافق': 2,
            'لا أوافق مطلقا': 1,
            'Strongly Agree': 5,
            'Agree': 4,
            'Neutral': 3,
            'Disagree': 2,
            'Strongly Disagree': 1
        };
        let currentResponseValueMap = { ...defaultResponseValueMap }; // Active map, can be overridden
        let currentScaleOptions = Object.keys(defaultResponseValueMap).sort((a, b) => defaultResponseValueMap[b] - defaultResponseValueMap[a]);
        let positiveScaleOptions = new Set(); // New Set to store positive scale options

        const responseColors = [
            'rgb(54, 162, 235)', // Light blue for positive
            'rgb(75, 192, 192)', // Green for agree
            'rgb(255, 205, 86)', // Yellow for neutral
            'rgb(255, 99, 132)', // Red for disagree
            'rgb(201, 203, 207)'  // Grey for strongly disagree
        ];
        
        let currentLang = 'en';
        let dataOrientation = 'vertical'; // Default data orientation
        let allCharts = {}; // Store chart instances to destroy them later

        /**
         * Transposes a 2D array.
         * @param {Array<Array<any>>} array The 2D array to transpose.
         * @returns {Array<Array<any>>} The transposed 2D array.
         */
        function transposeArray(array) {
            if (!array || array.length === 0 || array[0].length === 0) {
                return [];
            }
            const numRows = array.length;
            const numCols = array[0].length;
            const transposed = [];

            for (let j = 0; j < numCols; j++) {
                transposed[j] = [];
                for (let i = 0; i < numRows; i++) {
                    transposed[j][i] = array[i][j];
                }
            }
            return transposed;
        }

        // Event listener for file selection
        xlsxFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                showMessage(languageData[currentLang].fileError, 'error');
                return;
            }

            loadingMessage.classList.remove('hidden');
            // Hide all subsequent sections when a new file is chosen
            resultsContainer.classList.add('hidden');
            chartContainer.classList.add('hidden');
            actionButtons.classList.add('hidden');
            domainSection.classList.add('hidden');
            messageBox.classList.add('hidden');
            scaleOrderMessageBox.classList.add('hidden');
            scaleOrderSection.classList.add('hidden'); // Hide scale order until parsed
            domainMessageBox.classList.add('hidden'); // Hide domain message box
            positiveNegativeItemsContainer.classList.add('hidden'); // Hide positive/negative items container

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const parsedData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    if (parsedData.length < 2) {
                        showMessage(languageData[currentLang].emptyFile, 'error');
                        return;
                    }
                                        
                    sessionStorage.setItem('parsedData', JSON.stringify(parsedData));

                    const identifiedResponses = new Set();
                    let dataToScanForResponses = [];

                    if (dataOrientation === 'vertical') {
                        dataToScanForResponses = parsedData.slice(1).flatMap(row => row.slice(1));
                    } else {
                        dataToScanForResponses = parsedData.slice(1).flatMap(row => row.slice(1));
                    }

                    dataToScanForResponses.forEach(response => {
                        if (typeof response === 'string' && response.trim() !== '' && isNaN(Number(response))) {
                            identifiedResponses.add(String(response).trim());
                        }
                    });

                    const sortedIdentifiedResponses = Array.from(identifiedResponses).sort((a, b) => {
                        const valA = currentResponseValueMap[a] !== undefined ? currentResponseValueMap[a] : -Infinity;
                        const valB = defaultResponseValueMap[b] !== undefined ? defaultResponseValueMap[b] : -Infinity;

                        if (valA !== -Infinity && valB !== -Infinity) {
                            return valB - valA;
                        } else if (valA !== -Infinity) {
                            return -1;
                        } else if (valB !== -Infinity) {
                            return 1;
                        }
                        return a.localeCompare(b);
                    });

                    currentScaleOptions = sortedIdentifiedResponses;
                    // Reset positiveScaleOptions if new data is loaded
                    positiveScaleOptions.clear();
                    // Pre-select known positive options if they exist in the identified responses
                    ['Strongly Agree', 'Agree', 'أوافق تماما', 'أوافق'].forEach(positiveOption => {
                        if (identifiedResponses.has(positiveOption)) {
                            positiveScaleOptions.add(positiveOption);
                        }
                    });

                    renderScaleOptions(); // This will render and show the scale order section
                    domainSection.classList.remove('hidden'); // Show domain section
                    actionButtons.classList.remove('hidden'); // Show action buttons

                    // Display total items identified
                    const totalItemsInFile = dataOrientation === 'vertical' ? parsedData.slice(1).length : parsedData[0].slice(1).length;
                    if (totalItemsDisplay) totalItemsDisplay.textContent = languageData[currentLang].totalItemsDisplay.replace('{total}', totalItemsInFile);

                    scaleOrderSection.classList.remove('hidden'); // Show ranking widget after file upload
                } catch (error) {
                    console.error("Error parsing or displaying data:", error);
                    showMessage(languageData[currentLang].parseError, 'error');
                } finally {
                    if (loadingMessage) loadingMessage.classList.add('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // Event listener for "Analyze Data" button
        analyzeButton.addEventListener('click', () => {
            const storedParsedData = JSON.parse(sessionStorage.getItem('parsedData'));
            if (!storedParsedData) {
                showMessage(languageData[currentLang].fileError, 'error');
                return;
            }

            if (currentScaleOptions.length === 0) {
                showScaleOrderMessage(languageData[currentLang].scaleOrderEmpty, 'error');
                return;
            }

            const domainSizesInput = domainInput.value.trim();
            const domainSizes = domainSizesInput.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n) && n > 0);
            
            const totalItemsInFile = dataOrientation === 'vertical' ? storedParsedData.slice(1).length : storedParsedData[0].slice(1).length;
            const totalItemsFromInput = domainSizes.reduce((sum, size) => sum + size, 0);

            if (domainSizes.length > 0 && totalItemsFromInput !== totalItemsInFile) {
                showDomainMessage(languageData[currentLang].domainItemsError.replace('{sum}', totalItemsFromInput).replace('{total}', totalItemsInFile), 'error');
                return;
            }

            if (domainSizes.length > 0) {
                displayDomainResults(storedParsedData, domainSizes);
            } else {
                displayFullResults(storedParsedData);
            }
            resultsContainer.classList.remove('hidden');
            chartContainer.classList.remove('hidden');
            positiveNegativeItemsContainer.classList.remove('hidden'); // Show positive/negative items container
        });

        // Function to display messages (error/info)
        function showMessage(msg, type = 'info') {
            messageBox.classList.remove('hidden');
            messageText.textContent = msg;
            if (type === 'error') {
                messageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                messageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                messageBox.querySelector('svg path').setAttribute('fill-rule', 'evenodd');
                messageBox.querySelector('svg path').setAttribute('d', 'M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z');
                messageBox.querySelector('svg path').setAttribute('clip-rule', 'evenodd');
                document.getElementById('messageTitle').textContent = languageData[currentLang].error;
            } else {
                messageBox.classList.remove('bg-red-100', 'border-red-500', 'text-red-700');
                messageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                messageBox.querySelector('svg path').removeAttribute('fill-rule');
                messageBox.querySelector('svg path').removeAttribute('d');
                messageBox.querySelector('svg path').setAttribute('d', 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');
                document.getElementById('messageTitle').textContent = 'Info!'; // Or other info title
            }
        }

        // Function to show messages specifically for scale order
        function showScaleOrderMessage(msg, type = 'info') {
            scaleOrderMessageBox.classList.remove('hidden');
            scaleOrderMessageText.textContent = msg;
            if (type === 'error') {
                scaleOrderMessageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                scaleOrderMessageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('fill-rule', 'evenodd');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('d', 'M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('clip-rule', 'evenodd');
                scaleOrderMessageTitle.textContent = languageData[currentLang].error;
            } else {
                scaleOrderMessageBox.classList.remove('bg-red-100', 'border-red-500', 'text-red-700');
                scaleOrderMessageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                scaleOrderMessageBox.querySelector('svg path').removeAttribute('fill-rule');
                scaleOrderMessageBox.querySelector('svg path').removeAttribute('d');
                scaleOrderMessageBox.querySelector('svg path').setAttribute('d', 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');
                scaleOrderMessageTitle.textContent = 'Info!';
            }
        }

        // Function to show messages specifically for domain section
        function showDomainMessage(msg, type = 'info') {
            domainMessageBox.classList.remove('hidden');
            domainMessageText.textContent = msg;
            if (type === 'error') {
                domainMessageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                domainMessageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                domainMessageBox.querySelector('svg path').setAttribute('fill-rule', 'evenodd');
                domainMessageBox.querySelector('svg path').setAttribute('d', 'M10 18a8 8 0 100-16 8 8 0 000 16zm-1-8a1 112 0 1 11-2z');
                domainMessageBox.querySelector('svg path').setAttribute('clip-rule', 'evenodd');
                domainMessageTitle.textContent = languageData[currentLang].error;
            } else {
                domainMessageBox.classList.remove('bg-red-100', 'border-red-500', 'text-red-700');
                domainMessageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                domainMessageBox.querySelector('svg path').removeAttribute('fill-rule');
                domainMessageBox.querySelector('svg path').removeAttribute('d');
                domainMessageBox.querySelector('svg path').setAttribute('d', 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z');
                domainMessageTitle.textContent = 'Info!';
            }
        }

        // Function to process and display results (full questionnaire)
        function displayFullResults(data) {
            resultsContainer.innerHTML = '';
            chartContainer.innerHTML = ''; // Clear charts
            positiveNegativeItemsContainer.innerHTML = ''; // Clear positive/negative items
            destroyAllCharts(); // Destroy existing chart instances

            let items;
            let responses;

            if (dataOrientation === 'vertical') {
                items = data.slice(1).map(row => row[0]); // First column for items
                responses = data.slice(1).map(row => row.slice(1)); // Remaining columns for responses
            } else { // Horizontal
                items = data[0].slice(1); // First row (from second column) for items
                responses = transposeArray(data.slice(1).map(row => row.slice(1))); // Transpose responses, excluding ID column
            }

            if (enableItemTrimming) {
                items = items.map(item => {
                    const match = item.match(/\[(.*?)\]/);
                    return match ? match[1] : item;
                });
            }


            const totalRespondents = responses[0] ? responses[0].length : 0;
            const tableData = [];

            // Calculate overall frequencies and percentages for the full questionnaire
            const overallFrequencies = {};
            currentScaleOptions.forEach(option => overallFrequencies[option] = 0);

            responses.forEach(itemResponses => {
                itemResponses.forEach(response => {
                    const trimmedResponse = String(response).trim();
                    if (overallFrequencies.hasOwnProperty(trimmedResponse)) {
                        overallFrequencies[trimmedResponse]++;
                    }
                });
            });

            // Calculate overall total for percentage calculation
            const overallTotalResponses = Object.values(overallFrequencies).reduce((sum, count) => sum + count, 0);

            // Populate currentResponseValueMap based on currentScaleOptions order
            currentScaleOptions.forEach((option, index) => {
                currentResponseValueMap[option] = currentScaleOptions.length - index;
            });


            // Process each item
            items.forEach((item, index) => {
                const itemResponses = responses[index];
                const frequencies = {};
                let positivesSum = 0; // Initialize positives sum for the item
                currentScaleOptions.forEach(option => frequencies[option] = 0); // Initialize all options to 0

                itemResponses.forEach(response => {
                    const trimmedResponse = String(response).trim();
                    if (frequencies.hasOwnProperty(trimmedResponse)) {
                        frequencies[trimmedResponse]++;
                    }
                    if (positiveScaleOptions.has(trimmedResponse)) {
                        positivesSum++; // Increment if the response is marked as positive
                    }
                });

                const rowData = {
                    item: item,
                    frequencies: frequencies,
                    totalResponses: itemResponses.length,
                    mean: calculateMean(itemResponses), // Keep mean for sorting
                    positives: positivesSum // Add the calculated positives sum
                };
                tableData.push(rowData);
            });

            // Sort table data by mean in descending order
            tableData.sort((a, b) => b.mean - a.mean);

            // Render the main table
            renderTable(tableData, 'full', resultsContainer);
            
            // Filter items for positive lists
            const itemsWithPositives = tableData.map(item => ({
                item: item.item,
                positivesPercentage: item.totalResponses > 0 ? ((item.positives / item.totalResponses) * 100) : 0
            }));

            const highPositives = itemsWithPositives.filter(item => item.positivesPercentage >= 85);
            const lowPositives = itemsWithPositives.filter(item => item.positivesPercentage < 85);

            renderPositiveItemsLists(highPositives, lowPositives);


            // Render the overall chart
            const overallChartLabels = Object.keys(overallFrequencies);
            const overallChartDataValues = Object.values(overallFrequencies);
            const overallTotalResponsesForChart = overallChartDataValues.reduce((sum, val) => sum + val, 0);
            const overallChartPercentages = overallChartDataValues.map(val => overallTotalResponsesForChart > 0 ? ((val / overallTotalResponsesForChart) * 100).toFixed(2) : 0);

            const fullResultsDatasets = [{
                label: 'Percentage',
                data: overallChartPercentages,
                backgroundColor: responseColors.slice(0, overallChartLabels.length),
                borderColor: responseColors.slice(0, overallChartLabels.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                borderWidth: 1
            }];
            renderChart(overallChartLabels, fullResultsDatasets, 'fullResultsChart', languageData[currentLang].chartTitle);

            actionButtons.classList.remove('hidden');
        }

        // Function to process and display results by domain
        function displayDomainResults(data, domainSizes) {
            resultsContainer.innerHTML = '';
            chartContainer.innerHTML = ''; // Clear charts
            positiveNegativeItemsContainer.innerHTML = ''; // Clear positive/negative items
            destroyAllCharts(); // Destroy existing chart instances

            let items;
            let responses;

            if (dataOrientation === 'vertical') {
                items = data.slice(1).map(row => row[0]); // First column for items
                responses = data.slice(1).map(row => row.slice(1)); // Remaining columns for responses
            } else { // Horizontal
                items = data[0].slice(1); // First row (from second column) for items
                responses = transposeArray(data.slice(1).map(row => row.slice(1))); // Transpose responses, excluding ID column
            }

            if (enableItemTrimming) {
                items = items.map(item => {
                    const match = item.match(/\[(.*?)\]/);
                    return match ? match[1] : item;
                });
            }

            // Populate currentResponseValueMap based on currentScaleOptions order
            currentScaleOptions.forEach((option, index) => {
                currentResponseValueMap[option] = currentScaleOptions.length - index;
            });

            let itemIndex = 0;
            const domainAverages = []; // To store domain averages for the overall domain table
            const allItemsWithPositives = []; // To collect all items for combined positive lists

            domainSizes.forEach((size, domainNum) => {
                const domainItems = items.slice(itemIndex, itemIndex + size);
                const domainResponses = responses.slice(itemIndex, itemIndex + size);

                const tableData = [];
                domainItems.forEach((item, index) => {
                    const originalItemIndex = itemIndex + index; // Index in the original responses array
                    const itemResponses = domainResponses[index];
                    const frequencies = {};
                    let positivesSum = 0; // Initialize positives sum for the item
                    currentScaleOptions.forEach(option => frequencies[option] = 0);

                    itemResponses.forEach(response => {
                        const trimmedResponse = String(response).trim();
                        if (frequencies.hasOwnProperty(trimmedResponse)) {
                            frequencies[trimmedResponse]++;
                        }
                        if (positiveScaleOptions.has(trimmedResponse)) {
                            positivesSum++;
                        }
                    });

                    const rowData = {
                        item: item,
                        frequencies: frequencies,
                        totalResponses: itemResponses.length,
                        mean: calculateMean(itemResponses), // Keep mean for sorting
                        positives: positivesSum
                    };
                    tableData.push(rowData);
                    allItemsWithPositives.push({
                        item: item,
                        positivesPercentage: rowData.totalResponses > 0 ? ((rowData.positives / rowData.totalResponses) * 100) : 0
                    });
                });

                // Sort table data by mean in descending order
                tableData.sort((a, b) => b.mean - a.mean);

                // Render table for the current domain
                renderTable(tableData, `domain-${domainNum + 1}`, resultsContainer, languageData[currentLang].domainNumber.replace('{number}', domainNum + 1));

                // Calculate average percentages and positives for the current domain
                const domainTotalResponses = domainResponses.flat().filter(r => String(r).trim() !== '').length;
                const domainScalePercentages = {};
                currentScaleOptions.forEach(option => domainScalePercentages[option] = 0);
                let domainPositivesSum = 0;

                domainResponses.forEach(itemResponses => {
                    itemResponses.forEach(response => {
                        const trimmedResponse = String(response).trim();
                        if (domainScalePercentages.hasOwnProperty(trimmedResponse)) {
                            domainScalePercentages[trimmedResponse]++;
                        }
                        if (positiveScaleOptions.has(trimmedResponse)) {
                            domainPositivesSum++;
                        }
                    });
                });

                // Convert raw frequencies to percentages for the domain
                for (const option in domainScalePercentages) {
                    domainScalePercentages[option] = domainTotalResponses > 0 ? ((domainScalePercentages[option] / domainTotalResponses) * 100) : 0;
                }
                const domainAvgPositivesPercentage = domainTotalResponses > 0 ? ((domainPositivesSum / domainTotalResponses) * 100) : 0;

                const domainMean = tableData.reduce((sum, row) => sum + row.mean, 0) / tableData.length;

                domainAverages.push({
                    domain: languageData[currentLang].domainNumber.replace('{number}', domainNum + 1),
                    mean: domainMean, // Keep mean for overall domain average chart
                    rank: 0, // Placeholder for rank, to be filled after sorting
                    scalePercentages: domainScalePercentages, // Average percentages for each scale in this domain
                    avgPositivesPercentage: domainAvgPositivesPercentage
                });

                // Render chart for the current domain
                const domainOverallFrequencies = {};
                currentScaleOptions.forEach(option => domainOverallFrequencies[option] = 0);

                domainResponses.forEach(itemResponses => {
                    itemResponses.forEach(response => {
                        const trimmedResponse = String(response).trim();
                        if (domainOverallFrequencies.hasOwnProperty(trimmedResponse)) {
                            domainOverallFrequencies[trimmedResponse]++;
                        }
                    });
                });
                const domainChartLabelsForCurrentDomain = Object.keys(domainOverallFrequencies);
                const domainChartDataValuesForCurrentDomain = Object.values(domainOverallFrequencies);
                const domainTotalResponsesForChart = domainChartDataValuesForCurrentDomain.reduce((sum, val) => sum + val, 0);
                const domainChartPercentagesForCurrentDomain = domainChartDataValuesForCurrentDomain.map(val => domainTotalResponsesForChart > 0 ? ((val / domainTotalResponsesForChart) * 100).toFixed(2) : 0);

                const domainResultsDatasets = [{
                    label: 'Percentage',
                    data: domainChartPercentagesForCurrentDomain,
                    backgroundColor: responseColors.slice(0, domainChartLabelsForCurrentDomain.length),
                    borderColor: responseColors.slice(0, domainChartLabelsForCurrentDomain.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                    borderWidth: 1
                }];
                renderChart(domainChartLabelsForCurrentDomain, domainResultsDatasets, `domainChart-${domainNum + 1}`, languageData[currentLang].domainChartTitle.replace('{number}', domainNum + 1), false, `chartContainer`);


                itemIndex += size;
            });

            // Filter items for positive lists (after all domains are processed)
            const highPositives = allItemsWithPositives.filter(item => item.positivesPercentage >= 85);
            const lowPositives = allItemsWithPositives.filter(item => item.positivesPercentage < 85);
            renderPositiveItemsLists(highPositives, lowPositives);


            // Sort domain averages by mean in descending order and add ranks
            domainAverages.sort((a, b) => b.mean - a.mean);
            domainAverages.forEach((domain, idx) => {
                domain.rank = idx + 1;
            });

            // Render overall domain averages table
            renderDomainAveragesTable(domainAverages, resultsContainer);

            // Add chart for domain averages (simple bar chart showing average percentages per scale option)
            const overallAverageScalePercentages = {};
            currentScaleOptions.forEach(option => {
                const sumOfAvgPercsForOption = domainAverages.reduce((sum, domain) => sum + (domain.scalePercentages[option] || 0), 0);
                overallAverageScalePercentages[option] = sumOfAvgPercsForOption / domainAverages.length;
            });

            const domainAveragesChartLabels = Object.keys(overallAverageScalePercentages);
            const domainAveragesChartDatasets = [{
                label: 'Average Percentage',
                data: Object.values(overallAverageScalePercentages).map(val => val.toFixed(2)),
                backgroundColor: responseColors.slice(0, domainAveragesChartLabels.length),
                borderColor: responseColors.slice(0, domainAveragesChartLabels.length).map(color => color.replace('rgb', 'rgba').replace(')', ', 1)')),
                borderWidth: 1
            }];

            renderChart(
                domainAveragesChartLabels,
                domainAveragesChartDatasets,
                'domainAveragesChart',
                languageData[currentLang].domainAveragesChartTitle,
                false // This is a simple bar chart now
            );

            actionButtons.classList.remove('hidden');
            chartContainer.classList.remove('hidden');
            positiveNegativeItemsContainer.classList.remove('hidden'); // Show positive/negative items container
        }

        // Function to render a table
        function renderTable(data, tableId, containerElement, title = '') {
            const tableWrapper = document.createElement('div');
            tableWrapper.className = 'mb-8 p-6 bg-gray-50 rounded-xl shadow-inner';
            if (title) {
                const titleElem = document.createElement('h2');
                titleElem.className = 'text-xl font-bold text-gray-700 mb-4 text-center';
                titleElem.textContent = title;
                tableWrapper.appendChild(titleElem);
            }

            const table = document.createElement('table');
            table.id = tableId;
            table.className = 'min-w-full bg-white border border-gray-300 rounded-lg overflow-hidden shadow-sm text-sm';

            // Create table header
            const thead = document.createElement('thead');
            thead.className = 'bg-gray-100';
            const headerRow = document.createElement('tr');

            // Headers order: No., Item, Scale Options (%), Total (%), Positives (%)
            const headers = [
                languageData[currentLang].tableHeaders.no,
                languageData[currentLang].tableHeaders.item,
                ...currentScaleOptions.map(option => `${option} (%)`), // Header will be like "Agree (%)"
                `${languageData[currentLang].tableHeaders.totalColumn} (%)`, // Total 100% column (moved before Positives)
                `${languageData[currentLang].tableHeaders.positives} (%)` // Positives header
            ];

            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.className = 'px-4 py-2 text-left text-gray-600 font-semibold uppercase border-b border-gray-300';
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');
            tbody.className = 'divide-y divide-gray-200';

            data.forEach((rowData, idx) => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';

                const tdNo = document.createElement('td');
                tdNo.className = 'px-4 py-2 border-b border-gray-300 whitespace-nowrap';
                tdNo.textContent = idx + 1;
                tr.appendChild(tdNo);

                const tdItem = document.createElement('td');
                tdItem.className = 'px-4 py-2 border-b border-gray-300';
                tdItem.textContent = rowData.item;
                tr.appendChild(tdItem);

                // Calculate sum of percentages for current row to ensure 100% for the row
                let sumOfCurrentRowPercentages = 0;
                const percentageCells = []; // Store cells to append them in order

                currentScaleOptions.forEach(option => {
                    const frequency = rowData.frequencies[option] || 0;
                    const percentage = rowData.totalResponses > 0 ? ((frequency / rowData.totalResponses) * 100) : 0;
                    percentageCells.push(`${percentage.toFixed(2)}%`); // Store formatted percentage
                    sumOfCurrentRowPercentages += percentage;
                });

                percentageCells.forEach(text => {
                    const tdPerc = document.createElement('td');
                    tdPerc.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                    tdPerc.textContent = text;
                    tr.appendChild(tdPerc);
                });

                const tdTotal = document.createElement('td');
                tdTotal.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                tdTotal.textContent = `${sumOfCurrentRowPercentages.toFixed(2)}%`; // Total for the row
                tr.appendChild(tdTotal);

                const tdPositives = document.createElement('td');
                tdPositives.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                const positivesPercentage = rowData.totalResponses > 0 ? ((rowData.positives / rowData.totalResponses) * 100).toFixed(2) : 0;
                tdPositives.textContent = `${positivesPercentage}%`; // Display positives as percentage
                tr.appendChild(tdPositives);

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            tableWrapper.appendChild(table);
            containerElement.appendChild(tableWrapper);

            // Add tfoot for totals
            let totalResponsesSumForAllItems = 0;
            const overallFrequenciesByScaleOption = {};
            currentScaleOptions.forEach(option => overallFrequenciesByScaleOption[option] = 0);
            let totalPositivesCount = 0; // Sum of raw positives counts across all items

            data.forEach(rowData => {
                totalResponsesSumForAllItems += rowData.totalResponses;
                totalPositivesCount += rowData.positives;
                currentScaleOptions.forEach(option => {
                    overallFrequenciesByScaleOption[option] += (rowData.frequencies[option] || 0);
                });
            });

            const tfoot = document.createElement('tfoot');
            tfoot.className = 'bg-gray-100 font-bold';
            const totalRow = document.createElement('tr');

            const tdTotalLabel = document.createElement('td');
            tdTotalLabel.className = 'px-4 py-2 text-left text-gray-800 border-t border-gray-300';
            tdTotalLabel.setAttribute('colspan', 2); // Span over No. and Item
            tdTotalLabel.textContent = languageData[currentLang].tableHeaders.totalRowLabel;
            totalRow.appendChild(tdTotalLabel);

            let overallPercentageSumCheck = 0; // To sum percentages to check for 100%

            currentScaleOptions.forEach(option => {
                const tdTotalPerc = document.createElement('td');
                tdTotalPerc.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
                const totalFreqForOption = overallFrequenciesByScaleOption[option];
                const totalPercForOption = totalResponsesSumForAllItems > 0 ? ((totalFreqForOption / totalResponsesSumForAllItems) * 100) : 0;
                tdTotalPerc.textContent = `${totalPercForOption.toFixed(2)}%`; // Only display percentage
                totalRow.appendChild(tdTotalPerc);
                overallPercentageSumCheck += totalPercForOption; // Sum the actual float for accuracy
            });

            const tdGrandTotal = document.createElement('td'); // Total of percentages (100%)
            tdGrandTotal.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
            tdGrandTotal.textContent = `${overallPercentageSumCheck.toFixed(2)}%`; // Should be close to 100%
            totalRow.appendChild(tdGrandTotal);

            const tdPositives = document.createElement('td'); // Use tdPositives directly
            tdPositives.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
            const overallPositivesPercentage = totalResponsesSumForAllItems > 0 ? ((totalPositivesCount / totalResponsesSumForAllItems) * 100).toFixed(2) : 0;
            tdPositives.textContent = `${overallPositivesPercentage}%`; // Display overall positives as percentage
            totalRow.appendChild(tdPositives);

            tfoot.appendChild(totalRow);
            table.appendChild(tfoot);

            // Add the 100% check text after the table
            const totalPercentageCheckText = document.createElement('p');
            totalPercentageCheckText.className = 'total-percentage-check-text text-center text-gray-700 mt-4 font-semibold';
            totalPercentageCheckText.textContent = `${languageData[currentLang].tableHeaders.totalPercentageLabel}: ${overallPercentageSumCheck.toFixed(2)}%`;
            tableWrapper.appendChild(totalPercentageCheckText);
        }

        // Function to render the overall domain averages table
        function renderDomainAveragesTable(domainAverages, containerElement) {
            const tableWrapper = document.createElement('div');
            tableWrapper.className = 'mb-8 p-6 bg-gray-50 rounded-xl shadow-inner';

            const titleElem = document.createElement('h2');
            titleElem.className = 'text-xl font-bold text-gray-700 mb-4 text-center';
            titleElem.textContent = languageData[currentLang].domainAverages;
            tableWrapper.appendChild(titleElem);

            const table = document.createElement('table');
            table.id = 'domainAveragesTable';
            table.className = 'min-w-full bg-white border border-gray-300 rounded-lg overflow-hidden shadow-sm text-sm';

            // Create table header
            const thead = document.createElement('thead');
            thead.className = 'bg-gray-100';
            const headerRow = document.createElement('tr');

            const headers = [
                languageData[currentLang].tableHeaders.no,
                languageData[currentLang].tableHeaders.item.replace('Item', 'Domain'), // "Domain" column
                ...currentScaleOptions.map(option => `${option} (%)`), // Scale percentages
                `${languageData[currentLang].tableHeaders.totalColumn} (%)`, // Total 100% column
                `${languageData[currentLang].tableHeaders.positives} (%)` // Positives as percentage
            ];

            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.className = 'px-4 py-2 text-left text-gray-600 font-semibold uppercase border-b border-gray-300';
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');
            tbody.className = 'divide-y divide-gray-200';

            domainAverages.forEach((domainData, idx) => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';

                const tdNo = document.createElement('td');
                tdNo.className = 'px-4 py-2 border-b border-gray-300 whitespace-nowrap';
                tdNo.textContent = idx + 1;
                tr.appendChild(tdNo);

                const tdDomain = document.createElement('td');
                tdDomain.className = 'px-4 py-2 border-b border-gray-300';
                tdDomain.textContent = domainData.domain;
                tr.appendChild(tdDomain);

                let sumOfCurrentRowPercentages = 0;
                const percentageCells = []; // Store cells to append them in order

                currentScaleOptions.forEach(option => {
                    const percentage = domainData.scalePercentages[option] || 0;
                    percentageCells.push(`${percentage.toFixed(2)}%`);
                    sumOfCurrentRowPercentages += percentage;
                });

                percentageCells.forEach(text => {
                    const tdPerc = document.createElement('td');
                    tdPerc.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                    tdPerc.textContent = text;
                    tr.appendChild(tdPerc);
                });

                const tdTotal = document.createElement('td');
                tdTotal.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                tdTotal.textContent = `${sumOfCurrentRowPercentages.toFixed(2)}%`;
                tr.appendChild(tdTotal);

                const tdPositives = document.createElement('td');
                tdPositives.className = 'px-4 py-2 border-b border-gray-300 text-center whitespace-nowrap';
                tdPositives.textContent = `${domainData.avgPositivesPercentage.toFixed(2)}%`;
                tr.appendChild(tdPositives);

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            
            // Add tfoot for overall totals (averages of percentages across all domains)
            const tfoot = document.createElement('tfoot');
            tfoot.className = 'bg-gray-100 font-bold';
            const overallTotalRow = document.createElement('tr');

            const tdOverallLabel = document.createElement('td');
            tdOverallLabel.className = 'px-4 py-2 text-left text-gray-800 border-t border-gray-300';
            tdOverallLabel.setAttribute('colspan', 2); // Span over No. and Domain
            tdOverallLabel.textContent = languageData[currentLang].tableHeaders.totalRowLabel;
            overallTotalRow.appendChild(tdOverallLabel);

            let overallTotalPercentageCheck = 0;
            const overallTotalPositivesPercentage = domainAverages.reduce((sum, domain) => sum + domain.avgPositivesPercentage, 0) / domainAverages.length;


            currentScaleOptions.forEach(option => {
                const avgOfScalePercs = domainAverages.reduce((sum, domain) => sum + (domain.scalePercentages[option] || 0), 0) / domainAverages.length;
                const tdOverallPerc = document.createElement('td');
                tdOverallPerc.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
                tdOverallPerc.textContent = `${avgOfScalePercs.toFixed(2)}%`;
                overallTotalRow.appendChild(tdOverallPerc);
                overallTotalPercentageCheck += avgOfScalePercs;
            });
            
            const tdOverallGrandTotal = document.createElement('td');
            tdOverallGrandTotal.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
            tdOverallGrandTotal.textContent = `${overallTotalPercentageCheck.toFixed(2)}%`;
            overallTotalRow.appendChild(tdOverallGrandTotal);

            const tdOverallPositives = document.createElement('td');
            tdOverallPositives.className = 'px-4 py-2 text-center border-t border-gray-300 whitespace-nowrap';
            tdOverallPositives.textContent = `${overallTotalPositivesPercentage.toFixed(2)}%`;
            overallTotalRow.appendChild(tdOverallPositives);

            tfoot.appendChild(overallTotalRow);
            table.appendChild(tfoot);

            // Add the 100% check text after the table
            const totalPercentageCheckText = document.createElement('p');
            totalPercentageCheckText.className = 'total-percentage-check-text text-center text-gray-700 mt-4 font-semibold';
            totalPercentageCheckText.textContent = `${languageData[currentLang].tableHeaders.totalPercentageLabel}: ${overallTotalPercentageCheck.toFixed(2)}%`;
            tableWrapper.appendChild(totalPercentageCheckText);


            tableWrapper.appendChild(table);
            containerElement.appendChild(tableWrapper);
        }

        // Function to render the new positive/negative items lists
        function renderPositiveItemsLists(highPositives, lowPositives) {
            positiveNegativeItemsContainer.innerHTML = ''; // Clear previous content

            const listSection = document.createElement('div');
            listSection.className = 'mb-8 p-6 bg-gray-50 rounded-xl shadow-inner grid grid-cols-1 md:grid-cols-2 gap-8';

            // High Positives List
            const highPositivesDiv = document.createElement('div');
            highPositivesDiv.className = 'flex flex-col';
            const highPositivesTitle = document.createElement('h2');
            highPositivesTitle.className = 'text-xl font-bold text-gray-700 mb-4 text-center';
            highPositivesTitle.textContent = languageData[currentLang].positiveItemsTitle; // Use new title
            highPositivesDiv.appendChild(highPositivesTitle);
            const highPositivesParagraph = document.createElement('p');
            highPositivesParagraph.className = 'text-gray-700 text-center';
            if (highPositives.length > 0) {
                highPositivesParagraph.textContent = highPositives.map(item => item.item).join(' & '); // Join with &
            } else {
                highPositivesParagraph.textContent = 'No items in this category.';
            }
            highPositivesDiv.appendChild(highPositivesParagraph);
            listSection.appendChild(highPositivesDiv);

            // Low Positives List
            const lowPositivesDiv = document.createElement('div');
            lowPositivesDiv.className = 'flex flex-col';
            const lowPositivesTitle = document.createElement('h2');
            lowPositivesTitle.className = 'text-xl font-bold text-gray-700 mb-4 text-center';
            lowPositivesTitle.textContent = languageData[currentLang].negativeItemsTitle; // Use new title
            lowPositivesDiv.appendChild(lowPositivesTitle);
            const lowPositivesParagraph = document.createElement('p');
            lowPositivesParagraph.className = 'text-gray-700 text-center';
            if (lowPositives.length > 0) {
                lowPositivesParagraph.textContent = lowPositives.map(item => item.item).join(' & '); // Join with &
            } else {
                lowPositivesParagraph.textContent = 'No items in this category.';
            }
            lowPositivesDiv.appendChild(lowPositivesParagraph);
            listSection.appendChild(lowPositivesDiv);

            positiveNegativeItemsContainer.appendChild(listSection);
        }

        // Custom plugin to draw labels above bars and hide Y-axis grid lines
        const customBarLabelPlugin = {
            id: 'customBarLabels',
            afterDatasetsDraw(chart, args, options) {
                const { ctx } = chart;

                ctx.save();
                ctx.font = 'bold 12px Inter';
                ctx.fillStyle = '#374151'; // Dark gray color for labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                chart.data.datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    if (!meta.hidden) {
                        meta.data.forEach((element, index) => {
                            const dataValue = dataset.data[index];
                            // Adjusted yPos to ensure label is fully visible above the bar
                            const yPos = element.y - 35; // moved up by 35px from the top of the bar for better visibility
                            ctx.fillText(`${dataValue}%`, element.x, yPos);
                        });
                    }
                });
                ctx.restore();
            },
            // Hook to modify scales before rendering to hide y-axis
            beforeLayout: (chart) => {
                const yScale = chart.options.scales.y;
                if (yScale) {
                    yScale.display = false; // Hide the Y-axis
                    // Also hide grid lines for the Y-axis
                    if (yScale.grid) {
                        yScale.grid.display = false;
                    }
                }
            }
        };
        Chart.register(customBarLabelPlugin);


        // Function to render a chart (now accepts labels array and datasets array)
        function renderChart(labelsArray, datasetsArray, canvasId, title, isStacked = false, containerId = 'chartContainer') {
            const chartSection = document.createElement('div');
            chartSection.className = 'p-6 bg-gray-50 rounded-xl shadow-inner flex flex-col justify-center items-center';

            const chartTitleElem = document.createElement('h3');
            chartTitleElem.className = 'text-lg font-semibold mb-4 text-gray-700';
            chartTitleElem.textContent = title;
            chartSection.appendChild(chartTitleElem);

            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'h-64 w-full';
            const canvas = document.createElement('canvas');
            canvas.id = canvasId;
            canvasWrapper.appendChild(canvas);
            chartSection.appendChild(canvasWrapper);

            document.getElementById(containerId).appendChild(chartSection);

            const ctx = document.getElementById(canvasId).getContext('2d');
            const newChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labelsArray,
                    datasets: datasetsArray.map(dataset => {
                        // Ensure data is parsed to float and percentages are calculated if not already
                        const dataForChart = dataset.data.map(val => {
                            if (typeof val === 'number') return val;
                            // Assuming it might be frequency here, recalculate if needed.
                            // For simplicity, now expects percentages in datasetsArray for this new renderChart
                            return parseFloat(val);
                        });
                        return {
                            ...dataset,
                            data: dataForChart
                        };
                    })
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 40 // Add 40px padding at the top to make space for labels
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: isStacked // Apply stacking if true
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            stacked: isStacked // Apply stacking if true
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y + '%';
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            display: isStacked // Display legend for stacked charts to show what each segment represents
                        },
                        customBarLabels: { // Make sure plugin options are passed here
                            // No custom options needed for this, but structure is here
                        }
                    }
                },
                plugins: [customBarLabelPlugin]
            });
            allCharts[canvasId] = newChart; // Store the chart instance
        }

        // Function to destroy all existing chart instances
        function destroyAllCharts() {
            for (const chartId in allCharts) {
                if (allCharts[chartId]) {
                    allCharts[chartId].destroy();
                }
            }
            allCharts = {}; // Reset the storage
        }


        // Helper function to calculate mean
        function calculateMean(responses) {
            if (responses.length === 0) return 0;
            const validResponses = responses.map(response => currentResponseValueMap[String(response).trim()]).filter(value => value !== undefined);
            if (validResponses.length === 0) return 0;
            const sum = validResponses.reduce((acc, val) => acc + val, 0);
            return sum / validResponses.length;
        }

        // Helper function to calculate standard deviation - removed from display, but kept if needed for other calcs
        function calculateStandardDeviation(responses, mean) {
            if (responses.length === 0) return 0;
            const validResponses = responses.map(response => currentResponseValueMap[String(response).trim()]).filter(value => value !== undefined);
            if (validResponses.length < 2) return 0; // Need at least two data points for SD
            const sumOfSquares = validResponses.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
            return Math.sqrt(sumOfSquares / (validResponses.length - 1));
        }

        // Function to update UI elements based on current language
        function updateUIForLanguage() {
            document.getElementById('mainTitle').textContent = languageData[currentLang].title;
            document.getElementById('subtitle').textContent = languageData[currentLang].subtitle;
            document.getElementById('fileButtonText').textContent = languageData[currentLang].fileButton;
            document.getElementById('loadingMessage').textContent = languageData[currentLang].loading;
            document.getElementById('exportButton').textContent = languageData[currentLang].exportButton;
            document.getElementById('copyTableButton').textContent = languageData[currentLang].copyTableButton;
            document.getElementById('analyzeButton').textContent = languageData[currentLang].analyzeButton;
            document.getElementById('domainTitle').textContent = languageData[currentLang].domainTitle;
            document.getElementById('domainSubtitle').textContent = languageData[currentLang].domainSubtitle;
            document.getElementById('dataOrientationLabel').textContent = languageData[currentLang].dataOrientationLabel;
            orientationVerticalSpan.textContent = languageData[currentLang].orientationVertical;
            orientationHorizontalSpan.textContent = languageData[currentLang].orientationHorizontal;
            document.getElementById('scaleOrderTitle').textContent = languageData[currentLang].scaleOrderTitle;
            document.getElementById('scaleOrderSubtitle').textContent = languageData[currentLang].scaleOrderSubtitle;
            trimItemsLabel.textContent = languageData[currentLang].trimItemsLabel;

            // Update template guide texts
            templateGuideTitle.textContent = languageData[currentLang].templateGuide.title;
            verticalTemplateContent.querySelector('p').textContent = languageData[currentLang].templateGuide.verticalDesc;
            horizontalTemplateContent.querySelector('p').textContent = languageData[currentLang].templateGuide.horizontalDesc;
            document.getElementById('vtHeaderItem').textContent = languageData[currentLang].templateGuide.vtHeaderItem;
            document.getElementById('vtHeaderResp1').textContent = languageData[currentLang].templateGuide.vtHeaderResp + ' 1';
            document.getElementById('vtHeaderResp2').textContent = languageData[currentLang].templateGuide.vtHeaderResp + ' 2';
            document.getElementById('htHeaderEmpty').textContent = languageData[currentLang].templateGuide.htHeaderEmpty;
            document.getElementById('htHeaderItem1').textContent = languageData[currentLang].templateGuide.htHeaderItem + ' 1'; // Add 1
            document.getElementById('htHeaderItem2').textContent = languageData[currentLang].templateGuide.htHeaderItem + ' 2'; // Add 2
            document.getElementById('htRow1Resp').textContent = languageData[currentLang].templateGuide.htRowResp + ' 1'; // Add 1
        }

        // Function to manage language toggle styles
        function updateLanguageToggleStyles() {
            if (currentLang === 'en') {
                langEnSpan.classList.add('bg-indigo-600', 'text-white');
                langEnSpan.classList.remove('bg-gray-200', 'text-gray-800');
                langArSpan.classList.add('bg-gray-200', 'text-gray-800');
                langArSpan.classList.remove('bg-indigo-600', 'text-white');
                document.documentElement.setAttribute('dir', 'ltr'); // Set direction to LTR
            } else {
                langArSpan.classList.add('bg-indigo-600', 'text-white');
                langArSpan.classList.remove('bg-gray-200', 'text-gray-800');
                langEnSpan.classList.add('bg-gray-200', 'text-gray-800');
                langEnSpan.classList.remove('bg-indigo-600', 'text-white');
                document.documentElement.setAttribute('dir', 'rtl'); // Set direction to RTL
            }
        }

        // Language toggle event listener
        langToggle.addEventListener('click', () => {
            currentLang = currentLang === 'en' ? 'ar' : 'en';
            updateUIForLanguage();
            updateLanguageToggleStyles();
            // Re-render sections that depend on language
            const storedParsedData = JSON.parse(sessionStorage.getItem('parsedData'));
            if (storedParsedData) {
                renderScaleOptions(); // Re-render scale options for new language
                const domainSizesInput = domainInput.value.trim();
                const domainSizes = domainSizesInput.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n) && n > 0);
                const totalItemsInFile = dataOrientation === 'vertical' ? storedParsedData.slice(1).length : storedParsedData[0].slice(1).length;
                if (totalItemsDisplay) totalItemsDisplay.textContent = languageData[currentLang].totalItemsDisplay.replace('{total}', totalItemsInFile);

                if (resultsContainer.childElementCount > 0) { // Check if results were already displayed
                    if (domainSizes.length > 0) {
                        displayDomainResults(storedParsedData, domainSizes);
                    } else {
                        displayFullResults(storedParsedData);
                    }
                }
            }
        });

        // Function to manage data orientation toggle styles
        function updateDataOrientationToggleStyles() {
            if (dataOrientation === 'vertical') {
                orientationVerticalSpan.classList.add('bg-indigo-600', 'text-white');
                orientationVerticalSpan.classList.remove('bg-gray-200', 'text-gray-800');
                orientationHorizontalSpan.classList.add('bg-gray-200', 'text-gray-800');
                orientationHorizontalSpan.classList.remove('bg-indigo-600', 'text-white');
            } else {
                orientationHorizontalSpan.classList.add('bg-indigo-600', 'text-white');
                orientationHorizontalSpan.classList.remove('bg-gray-200', 'text-gray-800');
                orientationVerticalSpan.classList.add('bg-gray-200', 'text-gray-800');
                orientationVerticalSpan.classList.remove('bg-indigo-600', 'text-white');
            }
            // The fileUploadSection is now always visible by default from HTML
        }

        // Data orientation toggle event listener
        dataOrientationToggle.addEventListener('click', () => {
            dataOrientation = dataOrientation === 'vertical' ? 'horizontal' : 'vertical';
            updateDataOrientationToggleStyles();
            // Clear previous results when orientation changes
            sessionStorage.removeItem('parsedData');
            resultsContainer.classList.add('hidden');
            chartContainer.classList.add('hidden');
            actionButtons.classList.add('hidden');
            domainSection.classList.add('hidden');
            scaleOrderSection.classList.add('hidden'); // Hide scale order until new file
            messageBox.classList.add('hidden');
            domainMessageBox.classList.add('hidden');
            scaleOrderMessageBox.classList.add('hidden');
            positiveNegativeItemsContainer.classList.add('hidden'); // Hide positive/negative items container
            xlsxFile.value = ''; // Clear the selected file
            totalItemsDisplay.textContent = ''; // Clear total items display
        });


        // Function to render scale options (ranking widget)
        function renderScaleOptions() {
            scaleOrderOptionsContainer.innerHTML = ''; // Clear existing options
            scaleOrderMessageBox.classList.add('hidden'); // Hide any previous messages

            currentScaleOptions.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'ranking-option';
                optionDiv.draggable = true;
                optionDiv.dataset.option = option;
                
                // Determine if the option is currently marked as positive
                const isPositive = positiveScaleOptions.has(option);

                optionDiv.innerHTML = `
                    <span class="ranking-option-text">${option}</span>
                    <div class="ranking-option-buttons">
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" class="sr-only peer positive-checkbox" ${isPositive ? 'checked' : ''} data-option="${option}">
                            <div class="relative w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                            <span class="ms-2 text-sm font-medium text-gray-900 dark:text-gray-300">${languageData[currentLang].positiveLabel}</span>
                        </label>
                        <button class="move-button move-up" data-direction="up">↑</button>
                        <button class="move-button move-down" data-direction="down">↓</button>
                        <button class="remove-button">&times;</button>
                    </div>
                `;
                scaleOrderOptionsContainer.appendChild(optionDiv);
            });
            attachDragDropListeners();
        }

        function updateScaleOptionsOrder() {
            const newOrder = [];
            Array.from(scaleOrderOptionsContainer.children).forEach(optionDiv => {
                newOrder.push(optionDiv.dataset.option);
            });
            currentScaleOptions = newOrder;
            // Update the currentResponseValueMap based on the new order
            currentScaleOptions.forEach((option, index) => {
                currentResponseValueMap[option] = currentScaleOptions.length - index;
            });
        }

        // Drag and Drop functionality
        let draggedItem = null;

        function attachDragDropListeners() {
            const options = scaleOrderOptionsContainer.querySelectorAll('.ranking-option');
            options.forEach(option => {
                option.addEventListener('dragstart', (e) => {
                    draggedItem = option;
                    setTimeout(() => option.classList.add('opacity-50'), 0);
                    e.dataTransfer.effectAllowed = 'move';
                });

                option.addEventListener('dragend', () => {
                    draggedItem.classList.remove('opacity-50');
                    draggedItem = null;
                });

                option.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Allow drop
                    const bounding = option.getBoundingClientRect();
                    const offset = bounding.y + (bounding.height / 2);
                    if (draggedItem && draggedItem !== option) {
                        if (e.clientY < offset) {
                            option.classList.remove('border-b-2', 'border-indigo-500');
                            option.classList.add('border-t-2', 'border-indigo-500');
                        } else {
                            option.classList.remove('border-t-2', 'border-indigo-500');
                            option.classList.add('border-b-2', 'border-indigo-500');
                        }
                    }
                });

                option.addEventListener('dragleave', (e) => {
                    option.classList.remove('border-t-2', 'border-indigo-500', 'border-b-2', 'border-indigo-500');
                });

                option.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedItem && draggedItem !== option) {
                        const bounding = option.getBoundingClientRect();
                        const offset = bounding.y + (bounding.height / 2);

                        if (e.clientY < offset) {
                            scaleOrderOptionsContainer.insertBefore(draggedItem, option);
                        } else {
                            scaleOrderOptionsContainer.insertBefore(draggedItem, option.nextSibling);
                        }
                        updateScaleOptionsOrder();
                    }
                    option.classList.remove('border-t-2', 'border-indigo-500', 'border-b-2', 'border-indigo-500');
                });
            });

            // Event delegation for move and remove buttons and positive checkbox
            scaleOrderOptionsContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('move-up')) {
                    const optionDiv = e.target.closest('.ranking-option');
                    if (optionDiv && optionDiv.previousElementSibling) {
                        scaleOrderOptionsContainer.insertBefore(optionDiv, optionDiv.previousElementSibling);
                        updateScaleOptionsOrder();
                    }
                } else if (e.target.classList.contains('move-down')) {
                    const optionDiv = e.target.closest('.ranking-option');
                    if (optionDiv && optionDiv.nextElementSibling) {
                        scaleOrderOptionsContainer.insertBefore(optionDiv.nextElementSibling, optionDiv);
                        updateScaleOptionsOrder();
                    }
                } else if (e.target.classList.contains('remove-button')) {
                    const optionDiv = e.target.closest('.ranking-option');
                    if (optionDiv) {
                        const optionText = optionDiv.dataset.option;
                        positiveScaleOptions.delete(optionText); // Remove from positive set if present
                        optionDiv.remove();
                        updateScaleOptionsOrder();
                    }
                } else if (e.target.classList.contains('positive-checkbox')) {
                    const checkbox = e.target;
                    const optionText = checkbox.dataset.option;
                    if (checkbox.checked) {
                        positiveScaleOptions.add(optionText);
                    } else {
                        positiveScaleOptions.delete(optionText);
                    }
                }
            });
        }

        // Export to XLSX functionality
        exportButton.addEventListener('click', () => {
            const wb = XLSX.utils.book_new();
            let ws_data_combined = [];
            let currentOffset = 0; // Keep track of rows added to the combined data

            // Helper to get table data for export
            const getTableExportData = (tableElement, titleText) => {
                const tableData = [];
                if (titleText) {
                    tableData.push([titleText]); // Add title
                    tableData.push([]); // Empty row for spacing
                }
                // Get headers
                const headers = Array.from(tableElement.querySelectorAll('thead th')).map(th => th.textContent.trim());
                tableData.push(headers);
                // Get tbody rows
                tableElement.querySelectorAll('tbody tr').forEach(row => {
                    const rowData = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());
                    tableData.push(rowData);
                });
                // Get tfoot row
                const footerRow = tableElement.querySelector('tfoot tr');
                if (footerRow) {
                    const footerRowData = Array.from(footerRow.querySelectorAll('td')).map(td => td.textContent.trim());
                    // Adjust footerRowData to align with headers for colspan
                    const adjustedFooterRowData = new Array(headers.length).fill(''); // Fill with empty strings
                    let colIndex = 0;
                    for (let i = 0; i < footerRowData.length; i++) {
                        const td = footerRow.children[i];
                        const colspan = parseInt(td.getAttribute('colspan') || '1');
                        adjustedFooterRowData[colIndex] = footerRowData[i];
                        colIndex += colspan;
                    }
                    tableData.push(adjustedFooterRowData);
                }
                return tableData;
            };

            // Main Results Table
            const mainTable = resultsContainer.querySelector('table#full');
            if (mainTable) {
                const mainTableTitle = languageData[currentLang].title;
                const data = getTableExportData(mainTable, mainTableTitle);
                ws_data_combined = ws_data_combined.concat(data);
                ws_data_combined.push([], []); // Add empty rows for spacing
            }

            // Domain Tables
            document.querySelectorAll('#resultsContainer table[id^="domain-"]').forEach(table => {
                const titleElem = table.closest('div').querySelector('h2');
                const domainTableTitle = titleElem ? titleElem.textContent.trim() : '';
                const data = getTableExportData(table, domainTableTitle);
                ws_data_combined = ws_data_combined.concat(data);
                ws_data_combined.push([], []); // Add empty rows for spacing
            });

            // Add Positive and Negative Items sections to export
            const positiveItemsPara = document.querySelector('#positiveNegativeItemsContainer p:nth-of-type(1)');
            const negativeItemsPara = document.querySelector('#positiveNegativeItemsContainer p:nth-of-type(2)');

            if (positiveItemsPara) {
                ws_data_combined.push([languageData[currentLang].positiveItemsTitle]);
                ws_data_combined.push([positiveItemsPara.textContent]);
                ws_data_combined.push([]); // Empty row for spacing
            }
            if (negativeItemsPara) {
                ws_data_combined.push([languageData[currentLang].negativeItemsTitle]);
                ws_data_combined.push([negativeItemsPara.textContent]);
                ws_data_combined.push([]); // Empty row for spacing
            }

            // Domain Averages Table
            const domainAveragesTable = document.getElementById('domainAveragesTable');
            if (domainAveragesTable) {
                const domainAveragesTitle = languageData[currentLang].domainAverages;
                const data = getTableExportData(domainAveragesTable, domainAveragesTitle);
                ws_data_combined = ws_data_combined.concat(data);
            }
            
            const ws = XLSX.utils.aoa_to_sheet(ws_data_combined);
            XLSX.utils.book_append_sheet(wb, ws, "Questionnaire Analysis");

            XLSX.writeFile(wb, "Questionnaire_Analysis.xlsx");
        });

        // Copy table to clipboard functionality
        copyTableButton.addEventListener('click', () => {
            let allTableText = '';

            // Helper to get table text for clipboard
            const getTableText = (tableElement, titleText) => {
                let text = '';
                if (titleText) {
                    text += titleText + '\n\n';
                }
                // Headers
                Array.from(tableElement.querySelectorAll('thead th')).forEach(th => {
                    text += th.textContent.trim() + '\t';
                });
                text += '\n';
                // Body rows
                tableElement.querySelectorAll('tbody tr').forEach(row => {
                    Array.from(row.children).forEach(cell => {
                        text += cell.textContent.trim() + '\t';
                    });
                    text += '\n';
                });
                // Footer row
                const footerRow = tableElement.querySelector('tfoot tr');
                if (footerRow) {
                    Array.from(footerRow.children).forEach(cell => {
                        text += cell.textContent.trim() + '\t';
                    });
                    text += '\n';
                }
                return text;
            };

            // Main Results Table
            const mainTable = resultsContainer.querySelector('table#full');
            if (mainTable) {
                allTableText += getTableText(mainTable, languageData[currentLang].title);
                allTableText += '\n\n'; // Add spacing
            }

            // Domain Tables
            document.querySelectorAll('#resultsContainer table[id^="domain-"]').forEach(table => {
                const titleElem = table.closest('div').querySelector('h2');
                const domainTableTitle = titleElem ? titleElem.textContent.trim() : '';
                allTableText += getTableText(table, domainTableTitle);
                allTableText += '\n\n'; // Add spacing
            });

            // Add Positive and Negative Items sections to clipboard text
            const positiveItemsPara = document.querySelector('#positiveNegativeItemsContainer p:nth-of-type(1)');
            const negativeItemsPara = document.querySelector('#positiveNegativeItemsContainer p:nth-of-type(2)');

            if (positiveItemsPara) {
                allTableText += languageData[currentLang].positiveItemsTitle + '\n';
                allTableText += positiveItemsPara.textContent + '\n\n';
            }
            if (negativeItemsPara) {
                allTableText += languageData[currentLang].negativeItemsTitle + '\n';
                allTableText += negativeItemsPara.textContent + '\n\n';
            }

            // Domain Averages Table
            const domainAveragesTable = document.getElementById('domainAveragesTable');
            if (domainAveragesTable) {
                allTableText += getTableText(domainAveragesTable, languageData[currentLang].domainAverages);
            }


            document.execCommand('copy');
            const el = document.createElement('textarea');
            el.value = allTableText;
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);

            showMessage(languageData[currentLang].tableCopied, 'info');
        });

        // Toggle for item trimming
        trimItemsToggle.addEventListener('change', () => {
            enableItemTrimming = trimItemsToggle.checked;
            // Re-analyze data if already displayed to apply trimming
            const storedParsedData = JSON.parse(sessionStorage.getItem('parsedData'));
            if (storedParsedData && resultsContainer.childElementCount > 0) {
                const domainSizesInput = domainInput.value.trim();
                const domainSizes = domainSizesInput.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n) && n > 0);
                if (domainSizes.length > 0) {
                    displayDomainResults(storedParsedData, domainSizes);
                } else {
                    displayFullResults(storedParsedData);
                }
            }
        });

        // Template Guide Button Listeners
        showVerticalTemplateBtn.addEventListener('click', () => {
            templateGuideContainer.classList.remove('hidden');
            verticalTemplateContent.classList.remove('hidden');
            horizontalTemplateContent.classList.add('hidden');
            updateUIForLanguage(); // Ensure template guide text is in current language
            document.getElementById('vtHeaderResp1').textContent = languageData[currentLang].templateGuide.vtHeaderResp + ' 1';
            document.getElementById('vtHeaderResp2').textContent = languageData[currentLang].templateGuide.vtHeaderResp + ' 2';
        });

        showHorizontalTemplateBtn.addEventListener('click', () => {
            templateGuideContainer.classList.remove('hidden');
            horizontalTemplateContent.classList.remove('hidden');
            verticalTemplateContent.classList.add('hidden');
            updateUIForLanguage(); // Ensure template guide text is in current language
        });

        closeTemplateGuideBtn.addEventListener('click', () => {
            templateGuideContainer.classList.add('hidden');
        });

        // Initial UI setup
        updateUIForLanguage();
        updateLanguageToggleStyles();
        updateDataOrientationToggleStyles(); // Ensure initial state reflects default 'vertical'

    });
    </script>
</body>
</html>

